---
title: "CADC Trigger Technical Exploration App"
output:
  flexdashboard::flex_dashboard:
     orientation: columns
     vertical_layout: scroll
     horitzonal_layout: scroll
date: "2023-11-22"
runtime: shinyin
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r, echo=FALSE, include=F}
library(tidyverse)
library(gghdx)
library(gt)
library(arrow)
library(janitor)
library(broom)
library(readxl) # just for activity table
library(ggiraph) # just for activiity
library(glue)
gghdx()
source("R/triggerApp_funcs.R")

forecast_source <-  c("cds","mars")[2]

df_cropland_lte_vhi_threshold_dc <- read_parquet("shinyAppData/df_cropland_lte_vhi_threshold_dc.parquet") 

if(forecast_source=="cds"){
df_ecmwf_zonal <- read_parquet("shinyAppData/df_ecmwf_zonal.parquet")
targets::tar_load(df_ecmwf_zonal_all)
}
if(forecast_source=="mars"){
df_ecmwf_zonal <- read_parquet("shinyAppData/df_ecmwf_mars_zonal.parquet") 
}


df_iri_adm0_pre <- read_parquet("shinyAppData/df_iri_adm0_pre.parquet") 
targets::tar_load(df_gtm_nextgen_adm0)
insuv <- df_gtm_nextgen_adm0 %>% 
  mutate(
    valid_mo = month(valid_date)
  ) %>% 
  rename(
    mm= "value"
  )
# targets::tar_load(df_ecmwf_zonal_all) # this used to be input for next step
if(forecast_source=="mars"){
  df_ecmwf_zonal_all <- df_ecmwf_zonal %>% 
    mutate(
    valid_mo =month(valid_date),
    # lt= lt- 1
  ) %>% 
    filter(stat== "mean")
  
}
if(forecast_source=="cds"){
  df_ecmwf_zonal_all <- df_ecmwf_zonal_all %>% 
    filter(stat== "mean") %>% 
    mutate(
      lt=lt-1,
      valid_mo =month(valid_date)
    )
  
}


targets::tar_load(df_era5_mo)

df_chirps <- read_csv(file.path(
  Sys.getenv("AA_DATA_DIR"),
  "public",
  "processed",
  "lac",
  "chirps_monthly_adm0.csv"
))


adjustable_leadtimes2 <-  function(publication_mo=find_pub_mos(5),valid_mo=5){
  publication_mo <- as.numeric(publication_mo)
  valid_mo <- as.numeric(valid_mo)
  multi_yr_pub <- publication_mo[1]>publication_mo[length(publication_mo)]
  if(multi_yr_pub){
    dec_idx <- which(!publication_mo>lag(publication_mo))-1
    publication_mo[dec_idx] # issue if skip Dec?
    prev_year_mos <- publication_mo[1:dec_idx]
    prev_year_dates <- as_date(paste0("2020-", formatC(prev_year_mos,
                                    digits = 2,
                                    flag = "0",
                                    width = 2),"-01"))
    next_year_mos <-  publication_mo[(dec_idx+1):length(publication_mo)]
    next_year_dates <- as_date(paste0("2021-", formatC(next_year_mos,
                                    digits = 2,
                                    flag = "0",
                                    width = 2),"-01"))
    all_dates <- c(prev_year_dates,next_year_dates)
    min_pub_date <- min(all_dates)
    # not designed yet for multi yr validation
    min_valid_mo <- min(as.numeric(valid_mo))
     min_valid_date <- as_date(paste0("2021-", formatC(min_valid_mo,
                                    digits = 2,
                                    flag = "0",
                                    width = 2),"-01"))
     # this should be improved -- go direct from days to months rather than arith
    lts_days <- (min_valid_date- all_dates)+1
    # for some reaso counting 30 days as 0 months -- 
    # therefore add 1 to make it recognize as month = 1
    # lts_mos <- as.period(lts_days)%/% months(1)
    lts_mos <- round(lts_days/30)
    # as.period(31,"days")%/% months(1)
  }
  if(!multi_yr_pub){
    mon_mo <-  as.numeric(publication_mo)
    valid_start <- min(as.numeric(valid_mo))
    lts_mos <- return(valid_start- mon_mo)
  }
  return(lts_mos)
}
adjustable_leadtimes2_reactive <- reactive({
  adjustable_leadtimes2(publication_mo = as.numeric(input$winA_mon),
                        valid_mo = as.numeric(input$winA_forecast))
})
# adjustable_leadtimes2(publication_mo = find_pub_mos(5),valid_mo = 5)
adjustable_leadtimes <-  function(monitor_months, forecast_months){
  # browser()
   
  mon_mo <-  as.numeric(monitor_months)
  forecast_start <- min(as.numeric(forecast_months))
  return(forecast_start- mon_mo)
}

# Constructing Quadratic Formula
quad_eq <- function(a,b,c){
  if(delta(a,b,c) > 0){ # first case D>0
    x_1 = (-b+sqrt(delta(a,b,c)))/(2*a)
    x_2 = (-b-sqrt(delta(a,b,c)))/(2*a)
    result = c(x_1,x_2)
    return(result)
  }
  else if(delta(a,b,c) == 0){ # second case D=0
    x = -b/(2*a)
  }
  else {"There are no real roots."} # third case D<0
}
# Constructing delta
delta<-function(a,b,c){
  b^2-4*a*c
}

plt_color <- c(non_drought =hdx_hex("mint-hdx"),drought = hdx_hex("tomato-hdx"))

load_pub_mo_list <- function(ecmwf_source){
  if(ecmwf_source=="mars"){
    lt <- 6
  }
  if(ecmwf_source=="cds"){
    lt <- 5
  }
  set_names(c(1:12),
            month(c(1:12),label=T,abbr=T)
  ) %>% 
    map(\(mo_int){
      start_mo_int <- mo_int-lt
      seq_mo_int <-  start_mo_int:mo_int
      mo_seq<- ifelse(seq_mo_int<=0, seq_mo_int+12, seq_mo_int)
      return(mo_seq)
    }
    )
}
  
# provide valid mo's and return possible publication months that could be used
# to monitor status
find_pub_mos <-  function(x=c(5,6,7,8)){
  x <- as.numeric(unname(x))
  avail_mo_list <- load_pub_mo_list(ecmwf_source = forecast_source)
  month_diffs <- diff(c(x, x[1] + 12))
  
  # Find the index of the maximum difference
  max_diff_index <- which.max(month_diffs)
  
  # The maximum month is the one following the index with the maximum difference
  max_month <- x[max_diff_index]
  max_month_lab <- month(max_month,label=T, abbr=T)
  pub_mos <- avail_mo_list[[max_month_lab]]
  ret <- pub_mos[!(pub_mos %in% x[2:length(x)])]
  
  # hacky solution to fix the fact that if (for example)
  # we are monitoring:  5,6,7 we want to exclude May
  # but if just monitoring 5 there is nothing to exclude
  if(forecast_source=="mars"){
    if(length(x)==1){
      ret <- pub_mos
    } else{
      ret <- pub_mos[!(pub_mos %in% x[2:length(x)])]
    }
    
  }
  return(ret)
}

find_pub_mos_reactive <-  reactive({
  find_pub_mos(x = input$winA_forecast)
})
find_pub_mos_reactive_b <-  reactive({
  find_pub_mos(x = input$winB_forecast)
})

```


Inputs {.sidebar}
============================

```{r windowParams, echo=F,eval=F,out.width="100%"}
# Window & Countries
# Define reactive function
inputPanel(
  selectInput(inputId = "num_windows",
              choices = 1:3,
              selected = c(1),
              label = "Number of windows to define/monitor"
  ),
  checkboxGroupInput(inputId = "sel_country",
                     choices = c("El Salvador","Guatemala","Honduras","Nicaragua"),
                     selected = c("El Salvador","Guatemala","Honduras","Nicaragua"),
                     inline=T,
                     label = "Select Country to display"),
)
```



```{r temporalSel, echo=FALSE,out.width="100%"}

# inputPanel(
    selectInput(inputId = "num_windows",
              choices = 1:3,
              selected = c(1),
              label = "Number of windows to define/monitor"
  )
  checkboxGroupInput(inputId = "sel_country",
                     choices = c("El Salvador","Guatemala","Honduras","Nicaragua"),
                     selected = c("El Salvador","Guatemala","Honduras","Nicaragua"),
                     inline=T,
                     label = "Select Country to display")
  
  checkboxInput(inputId = "include_insuv",
                label = "Include INSUVIMEH data (Guatemala)",
                value = FALSE)
  
  


  checkboxGroupInput(inputId = "winA_forecast",
                     choices = c(1:12) %>%
                       set_names(month(1:12,label=T,abbr=T)),
                     selected = c(5,6,7,8),
                     inline=F,
                     label = "Step 1: Select time period/window of concert")
  
  
  # issue that this is rendering lazily
  # monitor_months <- reactive({find_pub_mos(x=input$winA_forecast)})
  renderUI({
    
    # monitor_months <- find_pub_mos(x=input$winA_forecast)
    monitor_months <- find_pub_mos_reactive()
    cat(monitor_months,"\n")
    checkboxGroupInput(
      inputId= "winA_mon",
      label = "2. Here are the available months we can monitor:",
      choices = monitor_months %>% set_names(month(monitor_months,label=T,abbr=T)),
      selected = monitor_months
    )
  })

  renderUI({
    if(forecast_source=="cds"){
      lts_tweak = adjustable_leadtimes(input$winA_mon, input$winA_forecast)
    }
    if(forecast_source=="mars"){
      # lts_tweak = adjustable_leadtimes2(as.numeric(input$winA_mon), as.numeric(input$winA_forecast) )
      lts_tweak = adjustable_leadtimes2_reactive()
      }
    # "Tweak Leadtimes",
    lts_tweak %>%
      sort() %>%
      map(\(lt){
        sliderInput(
          inputId = paste0("slider_", lt),
          label = paste("Adjust Leadtime ", lt),
          min = 1, max = 30, value = 4  # Adjust min, max, and value as needed
        )

      })
})
  selectInput(inputId = "sel_obs_corr",
            choices = c("ERA5","CHIRPS"),
            selected = c("ERA5"),
            label = "Select observational data set")
  actionButton("execute", "Generate data")
  
conditionalPanel(condition = "input.num_windows >= 2",
                 inputPanel(
                   
                   checkboxGroupInput(inputId="winB_forecast",
                                      choices = c(1:12) %>% set_names(month(1:12,label=T,abbr=T)),
                                      selected = c(9,10,11),
                                      inline=F, 
                                      label = "Window B Forecast Period"),
                   renderUI({
                     
                     monitor_months <- find_pub_mos_reactive_b()
                     # cat(monitor_months,"\n")
                     checkboxGroupInput(
                       inputId= "winB_mon",
                       label = "2. Here are the available months we can monitor:",
                       choices = monitor_months %>% set_names(month(monitor_months,label=T,abbr=T)),
                       selected = monitor_months
                     )
                   }
                   )
                 )
)
conditionalPanel(condition = "input.num_windows == 3",
                 inputPanel(
                   
                   checkboxGroupInput(inputId="winC_forecast",
                                      choices = c(1:12) %>% set_names(month(1:12,label=T,abbr=T)),
                                      selected = c(5,6,7),
                                      inline=T, 
                                      label = "Pre Alert Period"),
                   renderUI({
                     monitor_months <- available_leadtime_months(input$winC_forecast)
                     checkboxGroupInput(
                       inputId= "winC_mon",
                       label = "Select Monitoring Period",
                       choices = monitor_months %>% set_names(month(monitor_months,label=T,abbr=T)),
                       selected = monitor_months
                     )}
                     )
                   )
)

```



```{r eval=TRUE,echo=F}
# use_event_reactive <- F
# if(use_event_reactive){
# df_win1 <- eventReactive(input$winA_mon,{
#   # first filter to country and dates selected
#   df_ecmwf_win_filt1 <- df_ecmwf_zonal_all %>% 
#     filter(adm0_es %in% input$sel_country) %>% 
#     group_by(adm0_es,pub_date) %>% 
#     filter(
#       month(pub_date) %in% input$winA_mon,
#       valid_mo %in% input$winA_forecast
#     ) 
#   
#   # make sure that all forecast months are present
#   df_ecmwf_win_filt2 <- df_ecmwf_win_filt1 %>% 
#     group_by(adm0_es, pub_date) %>% 
#     filter(
#       all(input$winA_forecast %in% valid_mo)
#     )
#   
#   print(unique(df_ecmwf_win_filt1$adm0_es))
#   
#   
#   df_ecmwf_win_filt2 %>% 
#     summarise(
#       # sum the rainfall for each pub date (across lts)
#       mm = sum(mm),
#       
#       # grab min lt w/ each pub date.
#       lt= min(lt),
#       .groups = "drop"
#       
#     ) %>% 
#     mutate(
#       yr_date =floor_date(pub_date, "year")
#     )})  
# df_insuv <- reactive({
#   
#   gtm_selected<- ("Guatemala" %in% input$sel_country)
#   if(!gtm_selected){
#     ret <- NULL
#   }
#   if(gtm_selected){
#     insuv_filt <- insuv %>% 
#       filter(adm0_es %in% input$sel_country) %>% 
#       group_by(adm0_es,pub_date) %>% 
#       filter(
#         month(pub_date) %in% input$winA_mon,
#         valid_mo %in% input$winA_forecast
#       ) 
#     
#     insuv_filt2 <- insuv_filt %>% 
#       group_by(adm0_es, pub_date) %>% 
#       filter(
#         all(input$winA_forecast %in% valid_mo)
#       )
#     # browser()
#     ret <- insuv_filt2 %>% 
#       summarise(
#         mm = sum(mm),
#         lt= min(lt),
#         .groups = "drop"
#         
#       ) %>% 
#       mutate(
#         yr_date =floor_date(pub_date, "year")
#       )}
#   return(ret)
# }
# )
# }
# 
# 
# 
use_event_reactive <- F
if(!use_event_reactive){
  df_win1 <- reactive({
    
    filter_forecast(df = df_ecmwf_zonal_all,
                    country= input$sel_country,
                    pub_mon = input$winA_mon,
                    valid_mon = input$winA_forecast
                    )
  })
  df_insuv <- reactive({
    gtm_selected<- ("Guatemala" %in% input$sel_country)
    if(!gtm_selected){
      ret <- NULL
    }
    if(gtm_selected){
      
      ret <- filter_forecast(df = insuv,
                        country= input$sel_country,
                        pub_mon = input$winA_mon,
                        valid_mon = input$winA_forecast
        )
    }
    ret
  }
  )
}

if(use_event_reactive){
  df_win1 <- eventReactive(input$winA_mon,{
    browser()
    filter_forecast(df = df_ecmwf_zonal_all,
                    country= input$sel_country,
                    pub_mon = input$winA_mon,
                    valid_mon = input$winA_forecast
                    )
  })
  df_insuv <- eventReactive(input$winA_mon,{
    gtm_selected<- ("Guatemala" %in% input$sel_country)
    if(!gtm_selected){
      ret <- NULL
    }
    if(gtm_selected){
      ret <- filter_forecast(df = insuv,
                        country= input$sel_country,
                        pub_mon = input$winA_mon,
                        valid_mon = input$winA_forecast
        )
    }
    ret
  }
  )
}      
      
  
#   
# df_win1 <- reactive({
#   # first filter to country and dates selected
#   df_ecmwf_win_filt1 <- df_ecmwf_zonal_all %>% 
#     filter(adm0_es %in% input$sel_country) %>% 
#     group_by(adm0_es,pub_date) %>% 
#     filter(
#       month(pub_date) %in% input$winA_mon,
#       valid_mo %in% input$winA_forecast
#     ) 
#   
#   # make sure that all forecast months are present
#   df_ecmwf_win_filt2 <- df_ecmwf_win_filt1 %>% 
#     group_by(adm0_es, pub_date) %>% 
#     filter(
#       all(input$winA_forecast %in% valid_mo)
#     )
#   
#   
#   df_ecmwf_win_filt2 %>% 
#     summarise(
#       # sum the rainfall for each pub date (across lts)
#       mm = sum(mm),
#       
#       # grab min lt w/ each pub date.
#       lt= min(lt),
#       .groups = "drop"
#       
#     ) %>% 
#     mutate(
#       yr_date =floor_date(pub_date, "year")
#     )})

# same func for insuv... should just make generic

# df_insuv <- eventReactive(input$winA_mon,{
#   
#   gtm_selected<- ("Guatemala" %in% input$sel_country)
#   if(!gtm_selected){
#     ret <- NULL
#   }
#   if(gtm_selected){
#     insuv_filt <- insuv %>% 
#       filter(adm0_es %in% input$sel_country) %>% 
#       group_by(adm0_es,pub_date) %>% 
#       filter(
#         month(pub_date) %in% input$winA_mon,
#         valid_mo %in% input$winA_forecast
#       ) 
#     
#     insuv_filt2 <- insuv_filt %>% 
#       group_by(adm0_es, pub_date) %>% 
#       filter(
#         all(input$winA_forecast %in% valid_mo)
#       )
#     # browser()
#     ret <- insuv_filt2 %>% 
#       summarise(
#         mm = sum(mm),
#         lt= min(lt),
#         .groups = "drop"
#         
#       ) %>% 
#       mutate(
#         yr_date =floor_date(pub_date, "year")
#       )}
#   return(ret)
# }
# )



  
```




```{r, echo=F}


# dynamically grab the input values from the sliders
gather_slider_values <- reactive({
  if(forecast_source == "cds"){
  lts_tweak = adjustable_leadtimes(
    input$winA_mon, 
    input$winA_forecast) %>% 
    sort()  
  }
  if(forecast_source=="mars"){
      lts_tweak = adjustable_leadtimes2(
    input$winA_mon, 
    input$winA_forecast) %>% 
    sort()  
  }
  # go through each of the available leadtimes and take the slider value
  set_names(lts_tweak,lts_tweak) %>% 
    map(\(lt){
      input[[paste0("slider_", lt)]]
    })
  
})

dynamic_rps <- eventReactive(input$execute,{
  
  l_rps <- gather_slider_values()
  
  df_win_long <- df_win1() %>%
    select(-pub_date)
  
  ldf_rps <- l_rps %>%
    imap(
      \(rp,nm){
        q_rp <- 1/as.numeric(rp)
        df_win_long %>%
          filter(
            lt==nm
          ) %>%
          group_by(adm0_es) %>%
          reframe(
            !!sym(as.character(nm))  := quantile(mm,q_rp)
          )
      }
    )
  
  purrr::reduce(ldf_rps,left_join)
  
})

dynamic_rps_insuv <- eventReactive(input$execute,{
  
  l_rps <- gather_slider_values()
  
  df_win_long <- df_insuv() %>%
    select(-pub_date)
  
  ldf_rps <- l_rps %>%
    imap(
      \(rp,nm){
        q_rp <- 1/as.numeric(rp)
        df_win_long %>%
          filter(
            lt==nm
          ) %>%
          group_by(adm0_es) %>%
          reframe(
            !!sym(as.character(nm))  := quantile(mm,q_rp)
          )
      }
    )
  
  purrr::reduce(ldf_rps,left_join)
  
})

apply_dynamic_rps <- eventReactive(input$execute,{
  
  df_thresh_wide <- dynamic_rps()
  df_win <- df_win1()
  df_thresh_long<- df_thresh_wide %>%
    pivot_longer(
      cols= matches("\\b[0-6]\\b"),
      names_to ="lt",values_to = "q_ind"
    ) %>%
    mutate(
      lt= as.numeric(lt)
    )

   df_full <- df_win %>%
    left_join(
      df_thresh_long
    ) %>%
    mutate(
      lgl_flag = mm<q_ind
    )
  df_overall_activation_rate <- df_full %>%
    group_by(adm0_es,yr=year(pub_date)) %>%
    summarise(
      lgl_flag = any(lgl_flag)
    ) %>%
    summarise(
      ar_overall= mean(lgl_flag),
      rp_overall =1/ar_overall,.groups="drop"
    )

    rp_by_lt_indiv <- df_thresh_wide %>%
    left_join(
      df_overall_activation_rate
    )
    return(
      list(
        rp_by_lt_indiv= rp_by_lt_indiv,
        df = df_full
      )
    )
})
apply_dynamic_rps_insuv <- eventReactive(input$execute,
                                         input$include_insuv,{
  
  df_thresh_wide <- dynamic_rps_insuv()
  df_insuv <- df_insuv()
  
  df_thresh_long<- df_thresh_wide %>%
    pivot_longer(
      cols= matches("\\b[0-6]\\b"),
      names_to ="lt",values_to = "q_ind"
    ) %>%
    mutate(
      lt= as.numeric(lt)
    )

   df_full <- df_insuv %>%
    left_join(
      df_thresh_long
    ) %>%
    mutate(
      lgl_flag = mm<q_ind
    )
  df_overall_activation_rate <- df_full %>%
    group_by(adm0_es,yr=year(pub_date)) %>%
    summarise(
      lgl_flag = any(lgl_flag)
    ) %>%
    summarise(
      ar_overall= mean(lgl_flag),
      rp_overall =1/ar_overall,.groups="drop"
    )

    rp_by_lt_indiv <- df_thresh_wide %>%
    left_join(
      df_overall_activation_rate
    )
    return(
      list(
        rp_by_lt_indiv= rp_by_lt_indiv,
        df = df_full
      )
    )
})


df_era_prep <- reactive({df_era5_mo %>%
    clean_names() %>% 
    group_by(adm0_es=adm0_name,yr_date=floor_date(date, "year")) %>%
    filter(
      month(date) %in% input$winA_forecast
    ) %>% 
    summarise(
      mm_obs= sum(value)*1000
    ) })
df_chirps_prep <- reactive({df_chirps %>%
    clean_names() %>% 
    group_by(adm0_es=adm0_name,yr_date=floor_date(date, "year")) %>%
    filter(
      month(date) %in% input$winA_forecast
    ) %>% 
    summarise(
      mm_obs= sum(value)
    ) })

combine_forecast_observed <- function(forecast, observed){
  dfj<- forecast %>% 
    left_join(
      observed
    )
    
  df_r2 <- dfj %>% 
    group_by(adm0_es,lt) %>% 
    nest(data= c(-lt,-adm0_es) )%>% 
    mutate(
      corr_spear = map(data ,~cor.test(.x$mm,.x$mm_obs)),
      tidy =map(corr_spear,tidy),
      glanced = map(corr_spear,glance)
    ) %>% 
    unnest(tidy) %>% 
    select(adm0_es, lt, estimate)
  
  dfj %>% 
    left_join(df_r2)
}

df_era_seas_win <-  reactive({

  df_era_filt <- df_era_prep()
  dfj<- df_win1() %>% 
    left_join(
      df_era_filt
    )
  
  df_r2 <- dfj %>% 
    group_by(adm0_es,lt) %>% 
    nest(data= c(-lt,-adm0_es) )%>% 
    mutate(
      corr_spear = map(data ,~cor.test(.x$mm,.x$mm_obs)),
      tidy =map(corr_spear,tidy),
      glanced = map(corr_spear,glance)
    ) %>% 
    unnest(tidy) %>% 
    select(adm0_es, lt, estimate)
  dfj %>% 
    left_join(df_r2)
  
})


```



# Dynamic Thresholds 

```{r, echo=F}
render_gt({
  # ecmwf_thresh <- apply_dynamic_rps_static(df = df_win1())
  ecmwf_thresh <- apply_dynamic_rps()
  ecmwf_thresh_hist <- ecmwf_thresh$df
  ecmwf_summarised_tbl <- ecmwf_thresh$rp_by_lt_indiv
  
  if(!input$include_insuv){
    tbl_render <- ecmwf_summarised_tbl %>% 
      gt() %>% 
      cols_label(
        adm0_es="Country" ,
        ar_overall="Activation rate (overall)" ,
        rp_overall="Return period (overall)"
      ) %>% 
      tab_spanner(
        label = "Thresholds by LT",
        columns = any_of(c("0","1","2","3","4","5","6"))
      ) %>%
      fmt_number(columns = any_of(c("0","1","2","3","4","5","6")),decimals=0) %>% 
      fmt_number(columns = c("rp_overall"),decimals =2) %>% 
      fmt_percent(columns = c("ar_overall"),decimals =0)   
  }
  if(input$include_insuv){
    # insuv_thresh <- apply_dynamic_rps_static(df = df_insuv())$df
    
    insuv_thresh <- apply_dynamic_rps_insuv()$df
    
    # tbl_ecmwf_thresh <- apply_dynamic_rps_static(df = df_win1())$rp_by_lt_indiv
    f_thresh <- bind_rows(
      insuv_thresh %>% 
        mutate(
          source = "INSUVIMEH"  ,
          adm0_es = "Guatemala"
        ),
      ecmwf_thresh_hist %>% 
        mutate(
          source = "ECMWF"
        ) %>% 
        filter(adm0_es=="Guatemala")
      
    )
    f_overall <- f_thresh %>% 
      group_by(
        adm0_es,
        yr_pub_date = floor_date(pub_date,"year")
      ) %>% 
      summarise(
        lgl_flag= any(lgl_flag),.groups="drop_last"
      ) %>% 
      summarise(
        armf_overall = mean(lgl_flag),
        rpmf_overall = 1/armf_overall
      ) 
    
    # for each source
    f_insuv_indiv <- f_thresh %>% 
      group_by(
        adm0_es,
        yr_pub_date = floor_date(pub_date,"year"),
        source
      ) %>% 
      summarise(
        lgl_flag= any(lgl_flag)
      ) %>% 
      ungroup() %>% 
      group_by(adm0_es,source) %>% 
      summarise(
        armf = mean(lgl_flag)
      ) %>% 
      mutate(
        rpmf = 1/armf
      ) %>% 
      pivot_wider(names_from = source, values_from = armf:rpmf) %>% 
      select(-armf_ECMWF,-rpmf_ECMWF)
    
    
    df_insuvimeh_rps <- left_join(f_insuv_indiv,f_overall) 
    
    df_insuv_joined <- ecmwf_summarised_tbl %>% 
      left_join(
        df_insuvimeh_rps 
      )
    
    
    
   tbl_render <-  df_insuv_joined %>% 
      gt() %>% 
      cols_label(
        adm0_es="Country" ,
        ar_overall="ECMWF (overall)" ,
        rp_overall="Return period (overall)"
      ) %>% 
      tab_spanner(
        label = "Thresholds by LT",
        columns = any_of(c("0","1","2","3","4","5","6"))
      ) %>%
      fmt_number(columns = any_of(c("0","1","2","3","4","5","6")),decimals=0) %>% 
      fmt_number(columns = starts_with("rp"),decimals =2) %>% 
      fmt_percent(columns = starts_with("ar"),decimals =0) %>% 
      fmt_missing(
        missing_text = ""
      ) %>% 
      cols_merge(columns=c("ar_overall","rp_overall"),
                 pattern = "{1} ({2})"
                 
      ) %>% 
      # cols_merge(columns=c("armf_ECMWF","rpmf_ECMWF"),pattern = "{1} ({2})") %>% 
      cols_merge(columns=c("armf_INSUVIMEH","rpmf_INSUVIMEH"),
                 pattern = "{1} ({2})",
                 rows= !is.na(armf_INSUVIMEH)
      ) %>% 
      cols_merge(columns=c("armf_overall","rpmf_overall"),
                 pattern = "{1} ({2})",
                 rows =!is.na(armf_overall)) %>% 
      cols_label(
        armf_INSUVIMEH= "INSUVIMEH (overall)",
        armf_overall ="ECMWF + INSUVIMEH"
      )
  }
  tbl_render
  
})
```

Column {.tabset}
-----------------------------------------------------------------------

### Historical ECMWF

```{r, echo=F}
  renderPlot({
    # browser()
  gtm_sel <- "Guatemala" %in% input$sel_country
  # browser()
  df_p <- apply_dynamic_rps()$df
  # df_p <- apply_dynamic_rps_static(df = df_win1())$df
  
  
  p_ret <- df_p %>% 
    ggplot(
      aes(x= pub_date, y= mm, color=lgl_flag)
    )+
    geom_point()+
    scale_color_manual(values =unname(plt_color))+
    geom_hline(
      data = . %>% 
        distinct(adm0_es,lt,q_ind),
      aes(yintercept = q_ind)
    )+
    scale_x_date(
      date_breaks = "5 year",
      date_labels = "%y"
    )+
    geom_text(
      data= . %>%
        filter(lgl_flag),
      aes(x=pub_date, y= mm*0.85,label = format(pub_date,"%y")),
      size= 2
    )+
    theme(
      axis.title.x = element_blank(),
      axis.text.x = element_text(angle=90),
      legend.position  = "none",
      panel.border  = element_rect(fill=NA, color="lightgrey")
    )+
    facet_grid(row=vars(lt), cols = vars(adm0_es))
  
  p_ret
})


# renderPlot({
#   df_p <- apply_dynamic_rps()$df
#   df_p %>% 
#   group_by(
#     adm0_es,yr_date,lt
#   ) %>% 
#   summarise(
#     flags_per_lt = sum(lgl_flag),
#     .groups="drop"
#   ) %>% 
#   # mutate(
#   #   lt = as_factor(lt),
#   #   lt = fct_relevel(lt, "1","2","3")
#   # ) %>% 
#   ggplot(
#     aes(x= yr_date, y= flags_per_lt,fill=reorder(lt,-lt))
#   )+
#   geom_bar(stat= "identity")+
#       scale_x_date(
#       date_breaks = "5 year",
#       date_labels = "%y"
#     )+
#   facet_grid(cols =vars(adm0_es))+
#   theme(
#       axis.title.x = element_blank(),
#       axis.text.x = element_text(angle=90),
#       # legend.position  = "none",
#       panel.background = element_rect(fill=NA, color="lightgrey")
#     )
# }
# )
```

### ECMWF vs Observed (ERA5)

```{r, echo=F}
# input.winA_forecast

renderPlot({
  df_era_seas_plot <- combine_forecast_observed(forecast = df_win1(),observed = df_era_prep())
  title_valid_mo <- glue_collapse(month(as.numeric(input$winA_forecast),label=T, abbr=T),"-")
  
  max_y <- max(df_era_seas_plot$mm_obs,na.rm=T)
  pos_x <- max(df_era_seas_plot$mm,na.rm=T)*0.5
  df_era_seas_plot <- df_era_seas_plot %>% 
    group_by(
      adm0_es, lt
    ) %>% 
    mutate(
      pos_x= max(mm,na.rm=T)*0.3,
      pos_y = max(mm_obs,na.rm=T)*0.8
    ) %>% 
    ungroup()
  
  
  df_era_seas_plot %>% 
    ggplot(
      aes(x= mm, y= mm_obs)
    )+
    geom_point(alpha=0.5)+
    geom_abline (slope=1, linetype = "dashed", color="Red")+
    geom_smooth(method = "lm")+
    geom_text(
      data= . %>%
        distinct(adm0_es, lt, estimate,pos_x,pos_y),
      aes(
        label= paste0("R2: ",round(estimate,2)),
        x= pos_x,
        y=pos_y
        )
      
    )+
    facet_grid(
      rows= vars(adm0_es),
      cols = vars(lt)
    )+
    labs(
      title = "Forecast vs Observed by LT",
      subtitle =title_valid_mo,
      x= "ECMWF SEAS 51 Prediction (mm)",
      y= "ERA5 Historical Observation (mm)"
    )+
    theme(
      panel.border  = element_rect(fill=NA, color="lightgrey"),
      strip.text.y = element_text(size=8)
    )
})

```

### Forecasts(ECMWF vs INSUVIMEH)


```{r echo=F}
renderPlot({
  if(input$sel_obs_corr=="ERA5"){
    insuv_compare_df <- combine_forecast_observed(forecast = df_insuv(),observed = df_era_prep()) %>% 
      mutate(
        source = "INSUVIMEH"
      )
    ec_compare_df <- combine_forecast_observed(forecast = df_win1(),observed = df_era_prep()) %>% 
      filter(adm0_es == "Guatemala") %>% 
      mutate(
        source= "ECMWF"
      )
  }
  if(input$sel_obs_corr =="CHIRPS"){
    insuv_compare_df <- combine_forecast_observed(forecast = df_insuv(),observed = df_chirps_prep()) %>% 
      mutate(
        source = "INSUVIMEH"
      )
    ec_compare_df <- combine_forecast_observed(forecast = df_win1(),observed = df_chirps_prep()) %>% 
      filter(adm0_es == "Guatemala") %>% 
      mutate(
        source= "ECMWF"
      )
  }
  
  
  df_era_seas_plot <- bind_rows(insuv_compare_df,ec_compare_df)
  title_valid_mo <- glue_collapse(month(as.numeric(input$winA_forecast),label=T, abbr=T),"-")
  # browser()
  max_y <- max(df_era_seas_plot$mm_obs,na.rm=T)
  pos_x <- max(df_era_seas_plot$mm,na.rm=T)*0.5
  df_era_seas_plot <- df_era_seas_plot %>% 
    group_by(
      source,adm0_es, lt
    ) %>% 
    mutate(
      pos_x= max(mm,na.rm=T)*0.5,
      pos_y = max(mm_obs,na.rm=T)*0.8
    ) %>% 
    ungroup()
  
  
  p <- df_era_seas_plot %>% 
    ggplot(
      aes(x= mm, y= mm_obs)
    )+
    geom_point(alpha=0.5)+
    geom_abline (slope=1, linetype = "dashed", color="Red")+
    geom_smooth(method = "lm")+
    # geom_label(aes(x = 50, y = 1500, label = "x^2+y^2"), parse = TRUE) +
    geom_text(
      data= . %>%
        distinct(source,adm0_es, lt, estimate,pos_x,pos_y),
      aes(
        label= paste0("R^2",": ",round(estimate,2)),
        x= pos_x,
        y=pos_y
      ),parse=T
    )+
    facet_grid(
      rows= vars(source),
      cols = vars(lt)
    )+
    labs(
      title = glue("Guatemala Forecasts vs {input$sel_obs_corr} Observed by LT"),
      subtitle =title_valid_mo,
      x= "Forecast Prediction (mm)",
      y= "ERA5 Historical Observation (mm)"
    )+
    theme(
      panel.border = element_rect(fill=NA, color="grey")
    )
  p
})



```


### INSUVIMEH vs ECMWF corrs

```{r eval=T,echo=F}
renderPlot({
  era_prepped <- df_era_prep()
  
  insuv_comp <- combine_forecast_observed(forecast = df_insuv(),observed =era_prepped )
  ec_comp <- combine_forecast_observed(forecast = df_win1(),observed = era_prepped)
  
  df_corrs <- bind_rows(
  insuv_comp %>% 
    distinct(adm0_es, lt,estimate) %>% 
    mutate(
      source= "INSUVIMEH"
    ),
  ec_comp %>% 
    filter(adm0_es=="Guatemala") %>% 
    distinct(adm0_es, lt,estimate) %>% 
    mutate(
      source = "ECMWF"
    )
) 
df_corrs %>% 
  ggplot(aes(x= lt,y=estimate, color=source))+
  geom_point()

})

```


# Leadtime Bias

## Boxplot

```{r eval=T,echo=F}

# tar_load(df_ecmwf_zonal)
# tar_load(df_era5_mo)
# df_ecmwf_zonal_all <- df_ecmwf_zonal_all %>% 
#     mutate(
#     valid_mo =month(valid_date),
#     lt= lt- 1
#   ) %>% 
#     filter(stat== "mean")

renderPlot({
 df_win1() %>% 
  ggplot(
    aes(x= adm0_es, y= mm, fill=as_factor(lt))
  )+
  geom_boxplot(color="black")
})
  
```

# Performance against observed

How do we define a drought "event" (True Positive)?

```{r eval=T, echo=F}

fluidRow(
  column(5, offset = 1, style='padding:0px;' ,
         selectInput(inputId = "sel_observed",
                     label = "Define drought with VHI or Rainfall",
                     choices = c(`VHI (ASIS)` = "VHI",`Rainfall (ERA5)`= "Rainfall"),
                     selected = "Rainfall")
  ) #\ close col
  ,column(5, offset = 0, style='padding:0px;', 
          conditionalPanel(condition = "input.sel_observed == 'Rainfall'",
                           sliderInput(
                             inputId = "define_tp_era5",
                             label = "Whats a TP",
                             min = 1,
                             max = 20,
                             value = 4,
                             step = 1
                           )
                           
          )
  ), #\ close col
  column(5, offset = 0, style='padding:0px;', 
  conditionalPanel(condition = "input.sel_observed == 'VHI'",
                   column(5, offset = 0, style='padding:10px;', 
                   sliderInput(inputId = "vhi_thresh_perf", label = "VHI threshold:",
                               min = 0, max = 1, value = 0.35, step = 0.05)
                   ),
                   column(5, offset = 0, style='padding:10px;', 
                   sliderInput(inputId = "vhi_pct_perf", label = "% Cropland threshold:",
                               min = 0, max = 1, value = 0.25, step = 0.05)
                   ),
                   column(5, offset = 0, style='padding:10px;', 
                   checkboxGroupInput(
                     inputId = "vhi_months", label = "Months (ASIS)",
                     choices = c(6,7,8,9,10,11) %>% set_names(month(c(6,7,8,9,10,11),abbr=T,label=T)),
                     selected=7,inline=T
                               
                   )
                   )
  ) #\ close col
)
)


df_vhi_seas <- reactive({

  df_vhi_class <- df_cropland_lte_vhi_threshold_dc %>%
    filter(
      # abs(threshold-0.35)<0.01
      abs(threshold-input$vhi_thresh_perf)<0.01
    ) %>% 
    mutate(
      date = as_date(paste0(date,"-01"))
    ) %>% 
    filter(
      month(date) %in% input$vhi_months
    ) %>% 
    mutate(
      yr_date =floor_date(date,"year"),
      lgl_event = pct_crop_pixels_lte_thresh>=input$vhi_pct_perf
    ) %>% 
    ungroup()
  
    df_win1() %>% 
      ungroup() %>% 
    inner_join(
      df_vhi_class
    )
  
})



# obs_event <- 0.25

thresh_seq<- seq(0,
                 1,
                 by=0.01)

performance_colors <- c(
  TP = hdx_hex("mint-hdx"),   # Light green for True Positives
  FP = "darkred",   # Red for False Positives (most severe)
  FN = "tomato",   # Lighter red for False Negatives
  TN = "green" ,   # Dark green for True Negatives
  precision ="cyan"
)

# l_rps = c(`1` = 3,`2` =4,`3`=4)
dynamic_rp_tbl <- reactive({
  l_rps <- gather_slider_values()
  ldf_rps <- l_rps %>% 
    imap(
      \(rp,nm){
        q_rp <- 1/as.numeric(rp)
        tibble(
          lt = as.numeric(nm),
          threshold=q_rp
        )
      }
    ) %>% 
    list_rbind()
})
```

## Plot perf

```{r,echo=F,eval=T}
# library(ggiraph)

renderPlot({
  if(input$sel_observed=="Rainfall"){
  df_era_seas_ranked <- df_era_seas_win() %>% 
  group_by(adm0_es,lt) %>% 
  mutate(
    mm_obs_rank=dplyr::percent_rank(mm_obs),
    mm_forecast_rank = dplyr::percent_rank(mm)
  ) %>% 
  ungroup()


df_event_class <- df_era_seas_ranked %>% 
  mutate(
    lgl_event = mm_obs_rank <= 1/input$define_tp_era5
  )
  }
  if(input$sel_observed=="VHI"){
    df_event_class <- df_vhi_seas() %>% 
      group_by(adm0_es,lt) %>% 
      mutate(
        mm_forecast_rank = dplyr::percent_rank(mm)
      ) %>% 
      ungroup()
    
  }
  
  
df_perf <- thresh_seq %>% 
  map(\(thresh_temp){
    df_event_class %>% 
      mutate(
        lgl_thresh_forecast = mm_forecast_rank <= thresh_temp,
        TP = lgl_thresh_forecast & lgl_event,
        FP = lgl_thresh_forecast & !lgl_event,
        TN = !lgl_thresh_forecast & !lgl_event,
        FN = !lgl_thresh_forecast & lgl_event
        
      ) %>% 
      group_by(adm0_es, lt) %>% 
      summarise(
        TP = sum(TP,na.rm=T),
        FP= sum(FP,na.rm=T),
        TN = sum(TN,na.rm=T),
        FN= sum(FN,na.rm=T),
        precision = TP/(TP+FP),
        .groups = "drop"
      ) %>% 
      mutate(
        threshold_pctile = thresh_temp
      )
  }
  ) %>% 
  list_rbind()
perf_counts_long <-  df_perf %>%
  pivot_longer(
    cols = c(TP,FP,TN,FN),
    names_to = "metric",
    values_to = "value"
  ) 
# perf_counts_long2 <-  df_perf %>%
#   pivot_longer(
#     cols = c(TP,FP,TN,FN,precision),
#     names_to = "metric",
#     values_to = "value"
#   ) %>% 
#   mutate(
#     value = if_else(metric=="precision",round(value,2),value)
#   )
# df_vline <- perf_counts_long2 %>% 
#   left_join(
#     lt_thresh_tb
#   ) %>% 
#   mutate(
#     thresh_diff = threshold_pctile-0.15
#   ) %>% 
#   filter(
#    abs(thresh_diff)==min(abs(thresh_diff)) 
#    ) %>% 
#   mutate(
#     label = glue("{metric}: {value}\n")
#   ) %>% 
#   group_by(adm0_es,lt,threshold) %>% 
#   summarise(
#     label = glue_collapse(label,sep="\n")
  # )




perf_counts_long %>% 
  ggplot()+
  geom_line(
    aes(x= threshold_pctile,
        y= value,
        color= metric
      
        )
  )+
  scale_color_manual(values=performance_colors)+
  facet_grid(
    rows= vars(adm0_es),
    cols = vars(lt)
  )+
  geom_line(
    data= df_perf %>% 
      mutate(
        metric="precision",
        value = precision *50
        ) 
      ,
    aes(x= threshold_pctile, y= value, color= metric)
  )+
  # geom_vline_interactive(
  #   data= df_vline, aes(xintercept = threshold,tooltip=label)
  # )+
  scale_y_continuous( sec.axis = sec_axis(~./50, name = "precision"))+
  scale_x_reverse(labels=scales::label_percent(), breaks=seq(0,1,.05))+
  theme(
    panel.background = element_rect(fill=NA, color="black"),
    axis.text.x = element_text(angle = 90)
  )+
  labs(x= "threshold (≤)")
# girafe(ggobj = gp,width=10)
})


```

# Activity Timeline Plot
```{r plot-timeline, echo=F, fig.height=20}

fp <- file.path(Sys.getenv("AA_DATA_DIR"),
          "private",
          "processed",
          "lac",
          "cadc_partner_activity_matrix.xlsx")

dfa <- read_excel(fp) %>% 
    arrange(
    window,agency,adm0_es
  )

p_activities <- dfa %>% 
      pivot_longer(cols = latest_mo:implement_mo
      ) %>% 
  arrange(adm0_es) %>% 
      mutate(
        activity = trimws(activity),
        month = month(value,label=T, abbr= T),
        agency = case_when (
          str_detect(agency,"PAHO|WHO")~"PAHO/WHO",
          .default = agency),
        agency = fct_relevel(agency,"FAO","WFP","PAHO/WHO","UNICEF"),
        window = ifelse(window=="A","Window A (Primera)\nMJJJAS","Window B (Postrera)\nSON")
      ) %>% 
  mutate(
    activity = as_factor(activity),
    # activity = fct_reorder(activity,adm0_es)
  ) %>% 
      ggplot(
        aes(x=  activity,y = month, color = adm0_es, group=activity)
      )+
      geom_line()+
  scale_color_brewer(palette = "Spectral")+
      geom_point_interactive(
        aes(tooltip= str_wrap(activity,80))
      )+
      facet_grid(cols= vars(window),
                 rows= vars(agency),
                 scales = "free"
                 )+
      coord_flip()+
  scale_x_discrete(expand = c(0.1,0.1))+
     labs(title = "Proposed AA Activities",
          subtitle = "Central American Dry Corridor")+
      theme(
        axis.text.y = element_blank(),
        axis.title.x = element_blank(),
        axis.text.x = element_text(angle=90),
        panel.grid.minor = element_blank(),
        panel.grid.major = element_blank(),
        panel.background = element_rect(fill=NA,color="grey"),
        
      )


renderGirafe({
  girafe(ggobj= p_activities)
})
```
