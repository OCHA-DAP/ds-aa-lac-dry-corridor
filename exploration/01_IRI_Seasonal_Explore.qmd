---
title: "IRI Explore"
format: html
editor: visual
---

## Quarto

Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.

## Running Code

When you click the **Render** button a document will be generated that includes both content and the output of embedded code. You can embed code like this:

```{r}
library(sf)
library(rnaturalearth)
library(tidyverse)
library(reticulate)
library(ggridges)
library(glue)
library(gghdx)
library(exactextractr)
library(tmap)
library(tidync)
library(terra)
library(patchwork)
gghdx()


# I get errors using `{rhdx}` to try to et CODs for these countries so going w/ natural earth
aoi_countries <- ne_countries(country = c("Nicaragua",
                                          "Honduras",
                                          "Guatemala",
                                          "El Salvador")) %>% 
  st_as_sf() %>% 
  select(
    contains("admin"),
    iso_a3
  )

aoi_bbox <-  st_bbox(aoi_countries) %>% 
  st_as_sfc()


```

```{r eval=F}
# separating any setup that has to do w/ python (and setting eval =F) so anyone reviewing does not need to deal
# with setting up a python env

# pass to python
aoi_bbox_py <- reticulate::r_to_py(aoi_bbox)
```


```{python eval =F}
import pandas as pd
import geopandas as gpd
from shapely.geometry import Polygon
from ochanticipy import GeoBoundingBox
from ochanticipy import IriForecastDominant
from ochanticipy import create_custom_country_config
# import aatoolbox.utils.raster
from src import utils, constants
from ochanticipy import utils.raser
from ochanticipy import IriForecastProb


coords_array = r.aoi_bbox_py
coords_array_unnested = coords_array[0][0]
aoi_poly = Polygon(coords_array_unnested)

gdf_aoi_poly = gpd.GeoDataFrame({'geometry':[aoi_poly]})

fp_country_config = "lac.yaml"
country_config = create_custom_country_config(fp_country_config)

geo_bounding_box=GeoBoundingBox.from_shape(gdf_aoi_poly)

# download dominant tercile probability forecast
iri_dominant = IriForecastDominant(country_config=country_config,
                                   geo_bounding_box=geo_bounding_box)

# download tercile probability forecast
iri_prob = IriForecastProb(country_config=country_config,
                           geo_bounding_box=geo_bounding_box)
iri_dominant.download()
iri_dominant.process() # process


iri_dom_data = iri_dominant.load() # can load into python to see how it looks

# download and process prob
iri_prob.download()
iri_prob.process()
iri_prob_data = iri_prob.load()

```


```{r}

# load dominant tercile and prob terciles forecasts
fp_iri_dom <- file.path(
  Sys.getenv("AA_DATA_DIR"),
  "private",
  "processed",
  "lac",
  "iri",
  "lac_iri_forecast_seasonal_precipitation_tercile_dominant_Np18Sp10Em83Wm93.nc"
)

fp_iri_prob <- file.path(
  Sys.getenv("AA_DATA_DIR"),
  "private",
  "processed",
  "lac",
  "iri",
  "lac_iri_forecast_seasonal_precipitation_tercile_prob_Np18Sp10Em83Wm93.nc"
) 

iri_dom <- tidync(fp_iri_dom)
iri_prob <- tidync(fp_iri_prob)


#nv (named vector) - trying out this syntax
# add buffer to bbox for cropping otherwise grid get's messed up
nv_bbox <- st_bbox(aoi_countries %>% 
                     st_buffer(dist = 0))



iri_crop <- lst(iri_dom,iri_prob) %>% 
  map(
  ~.x %>% 
    hyper_filter(
    Y = between(Y, nv_bbox[2],nv_bbox[4]),
    X = between(X, nv_bbox[1],nv_bbox[3])
  )
  )


forecast_month_array <- iri_crop$iri_dom %>% 
  activate("F") %>%  # month
  hyper_array()



```

# Init Viz/Learning

```{r}
forecast_month_latest <- forecast_month_array$F %>% max()


iri_latest_lt1 <- iri_crop %>% 
  imap(\(ho,nm){
    ho_filt <- ho %>% 
      hyper_filter(
        L= L==1,  # leadtime 1
        `F` = `F`==forecast_month_latest # get latest month
      )
    if(nm=="iri_prob"){
      ho_filt <- ho_filt %>% 
        hyper_filter(
          `C` = `C`==1 # if prob dataset (not dom) take prob of below avg season
        )
    }
    return(ho_filt)
    
  }
  )
    

X_array_dom<-  iri_latest_lt1$iri_dom %>% 
    activate("X") %>% 
    hyper_array()

X_array_prob<-  iri_latest_lt1$iri_prob %>% 
    activate("X") %>% 
    hyper_array()

all(X_array_dom$X == X_array_prob$X)

X_array<-  iri_latest_lt1$iri_dom %>% 
    activate("X") %>% 
    hyper_array()

Y_array<-  iri_latest_lt1$iri_dom %>% 
    activate("Y") %>% 
    hyper_array()

iri_latest_lt1_da <- iri_latest_lt1 %>% 
  map2(.y =c("dominant","prob"),\(ho,band){
    ho %>% 
      hyper_array(select_var = band)
  })
iri_latest_lt1_da$iri_dom$dominant    
iri_latest_lt1_da$iri_prob$prob

  # reorder dims -- would need a more flexible application to generalize
  
iri_latest_lt1_da$iri_prob$prob %>% dim()
iri_latest_lt1_da$iri_dom$dom %>% dim()

r_iri <- map2(
  .x=iri_latest_lt1_da,
  .y = c("dominant","prob"), 
  \(ho_array,band){
     rast(
    x= aperm(ho_array[[band]],c(2,1)),
    extent =ext(
      min(X_array$X)-0.5,
      max(X_array$X)+0.5,
      min(Y_array$Y)-0.5,
      max(Y_array$Y)+0.5
    ),
    crs= "EPSG:4326"
  ) })


  
res(r_iri$iri_dom)
res(r_iri$iri_prob)
r_iri$iri_prob[[1]]  %>% plot()
r_iri$iri_dom[[1]]  %>% plot()
plot(aoi_countries$geometry,add=T)


r_iri_test <- r_iri$iri_prob
r_iri_test[is.na(r_iri_test)]<-1


exact_extract(x = r_iri$iri_prob,
              y = aoi_countries,
              fun="count",
              append_cols ="admin")

exact_extract(x = r_iri_dom_test,
              y = aoi_countries,
              fun="count",
              append_cols ="admin")



```

```{r}
tm_shape(r_iri$iri_prob)+
  tm_raster()+
  tm_shape(aoi_countries)+
  tm_borders(lwd = 3)
```


# Create Raster Collections

Create prob & dom rasters

```{r}

# split up tercile probability by leadtime
iri_prob_lt_split <-
  c(
    lt1=1,
    lt2=2,
    lt3=3,
    lt4=4
  ) %>% 
  map(
    ~iri_crop$iri_prob %>% 
      hyper_filter(
        L= L==.x
      )
  )

# split up dominant tercile by leadtime
iri_dom_lt_split <- 
  c(
    lt1=1,
    lt2=2,
    lt3=3,
    lt4=4
  ) %>% 
  map(
    ~iri_crop$iri_dom %>% 
      hyper_filter(
        L= L==.x
      )
  )

# convert each leadtime into array
da_iri_prob_lt_split <- iri_prob_lt_split %>% 
  map(
    ~.x %>% 
      hyper_array(select_var = "prob")
  )

da_iri_dom_lt_split <- iri_dom_lt_split %>% 
  map(
    ~.x %>% 
      hyper_array(select_var = "dominant")
  )


# extract coordinate arrays to use to align data to grids in raster    
lon_lat_names <-  c("X","Y")
coord_array<-  lon_lat_names%>% 
  map(
  ~ iri_dom_lt_split$lt1   %>% 
    activate(.x) %>% 
    hyper_array()
  ) %>% 
  set_names(lon_lat_names)

  


# dominant spatRaster by LT
r_dom_lt_split <-  da_iri_dom_lt_split %>% 
  map(
    ~ rast(
      # aperm allows you to rerrange dimensions into those expected by terra::rast()
      x= aperm(.x[["dominant"]],c(2,1,3)),
      extent =ext(
        min(coord_array$X$X)-.5,
        max(coord_array$X$X)+.5,
        min(coord_array$Y$Y)-.5,
        max(coord_array$Y$Y)+.5
      ),
      crs= "EPSG:4326"
    ) 
  )

# To access `C` (which tercile prob : 1. below, 2. normal, 3. above) you can index like so
aperm(da_iri_prob_lt_split$lt1[["prob"]],c(2,1,4,3))[,,,1] %>% dim()


# therefore fore the prob data we can map through each of the 4  leadtimes.
# and then for each of the 4 lead time map/iterate through each of the probability class (1:3)
# and make a nice list of probability rasters
r_prob_list <- da_iri_prob_lt_split %>% 
  map(
    \(da){
      da_reordered <- aperm(da[["prob"]],c(2,1,4,3))
      c(1:3) %>% 
        map(\(c_prob){
          da_c<- da_reordered[,,,c_prob] 
          rast(
            x= da_c,
            extent =ext(
              min(coord_array$X$X)-.5,
              max(coord_array$X$X)+.5,
              min(coord_array$Y$Y)-.5,
              max(coord_array$Y$Y)+.5
            ),
            crs= "EPSG:4326")
        }
        )
    }
  )
```

# Missing Pixels

need to add other missing pixel plot here

## Dominant Tercile Missing Pixels
```{r}
# sanity check - make sure rasters came out w/ same number of pixels as on single raster and that prob + Dom have same number

# sinc ethere are missing pixels - let's fill w/ 1 so we can get correct counts
r_dom_test <- r_dom_lt_split$lt1$lyr.1

r_dom_test[is.na(r_dom_test)]<-1


df_dom_pixel_count_adm0 <- exact_extract(x = r_dom_test,
              y = aoi_countries,
              fun="count",
              append_cols ="admin")

r_prob_test <- r_prob_list$lt1[[1]]$lyr.1

r_prob_test[is.na(r_prob_test)]<-1


df_prob_pixel_count <- exact_extract(x = r_prob_test,
              y = aoi_countries,
              fun="count",
              append_cols ="admin")

all(df_dom_pixel_count_adm0==df_prob_pixel_count)



```


```{r}
# get date vector to rename layers w/
dt_latest_month <- as_date("2023-08-01")
dt_earliest_month <- as_date("2023-08-01")-months(78)
dt_all_month <- seq(dt_earliest_month,dt_latest_month, by ="month") 
r_dom_lt_split %>% 
  map(~names(.x) %>% 
        length())

# odd mutability behaviour for R... but I don't really mind
r_dom_lt_split %>% 
  map(
    ~set.names(.x,dt_all_month)
  )

country_pixel_stats <- r_dom_lt_split %>% 
  imap(\(rtemp,nm){
    exact_extract(x = rtemp,
              y = aoi_countries,
              fun="count",
              append_cols ="admin") %>% 
    pivot_longer(-matches("admin")) %>%
    separate(name, into = c("stat", "date"), sep = "\\.") %>%
    pivot_wider(names_from = "stat", values_from = "value") %>% 
    mutate(
      date_forecast_made= as_date(date)
    ) %>% 
  left_join(df_dom_pixel_count_adm0 %>% 
              rename(total_pix =count)) %>% 
      mutate(
        pct_pix= count/total_pix,
        month = month(date,labe=T),
        pct_missing = 1- pct_pix,
        lt = parse_number(nm),
        date_predicted = date_forecast_made + months(lt),
        mo_pred = glue(
          "{month(date_predicted,label=T,abbr = T)}-{month(date_predicted+months(1),label=T,abbr = T)}-{month(date_predicted+months(2),label=T,abbr = T)}"
          )
      )
  }
  )
```



```{r tbl-pixel-count}  

df_country_pixel_stats <- bind_rows(country_pixel_stats)

df_country_pixel_stats %>%
  rename(`Number of pixels` ="total_pix") %>% 
  distinct(admin,`Number of pixels`) %>% 
  gt::gt()
```

```{r plot-ts-missing-pix-lt1}
# leadtime =1
df_country_pixel_stats %>% 
  mutate(
    date= as_date(date),
    leadtime = as_factor(lt)
  ) %>% 
  filter(leadtime==1) %>% 
  ggplot(aes(x=date,y=pct_missing))+
  geom_point()+
  geom_line()+
  scale_y_continuous(labels = scales::label_percent())+
  scale_x_date(date_breaks = "2 month",date_labels = "%b-%y")+
  labs(x="Date of Publication",y = "% pixels missing",
       title = "IRI Dom Forecast",
       subtitle = "% Monthly Pixels Missing By Country (Leadtime =1)")+
  facet_wrap(~admin)+
  theme(axis.text.x = element_text(angle=90))
```

```{r plot-ts-missing-pix-all-lt}
# time series line plot
df_country_pixel_stats %>% 
  mutate(
    date= as_date(date),
    leadtime = as_factor(lt)
  ) %>% 
  ggplot(aes(x=date,y=pct_missing,color=leadtime))+
  geom_point()+
  geom_line()+
  scale_y_continuous(labels = scales::label_percent())+
  scale_x_date(date_breaks = "2 month",date_labels = "%b-%y")+
    labs(x="Date of Publication",y = "% pixels missing",
       title = "IRI Dom Forecast",
       subtitle = "% Monthly Pixels Missing By Country & Leadtime")+
  facet_wrap(~admin)+
  theme(axis.text.x = element_text(angle=90))
```

```{r plot-point-distribution}


df_country_pixel_stats %>% 
  mutate(leadtime = as_factor(lt)) %>% 
  ggplot(aes(x=mo_pred,y=pct_missing,color=leadtime))+
  # geom_boxplot()+
    geom_point(size=1,alpha=0.5,
             position = position_jitter(w = .15,height = 0.005))+
  scale_y_continuous(labels = scales::label_percent())+
  facet_wrap(~admin)+
  labs(x="Season",title="% Missing Pixels",subtitle = "By Country, leadtime, and season")+
  theme(axis.text.x = element_text(angle=90),
        axis.title.y = element_blank()
        # legend.title = element_blank()
        )
```

```{r plot-boxplot-missingPx}  
df_country_pixel_stats %>% 
  ggplot(aes(x=mo_pred,y=pct_missing,color=as_factor(lt)))+
  geom_boxplot()+
  facet_wrap(~admin)+
  theme(axis.text.x = element_text(angle=90))
```


````{r plot-violin-missing-pixels}

p_box_pct_pixels <- country_pixel_stats %>%
  imap(\(dft,nm){
    dft %>% 
      ggplot(aes(x= month,y= pct_missing))+
      
      # geom_boxplot()+
      geom_violin()+
      geom_point(size=1,alpha=0.5,
             position = position_jitter(w = .15))+
      scale_y_continuous(labels = scales::label_percent())+
      labs(x="% Pixels Available",title = "% Pixels Missing By Forecast Publication Month",subtitle = nm)+
      facet_wrap(~admin)+
      theme(
        axis.title.y = element_blank()
      )
  }
  )

p_box_pct_pixels$lt1+
  theme(
        axis.title.x = element_blank(),
    axis.text.x= element_blank(),
  )+
  p_box_pct_pixels$lt2+
  theme(
    plot.title = element_blank(),
    axis.title.x = element_blank(),
    axis.text.x= element_blank(),
    axis.text.y=element_blank()
  )+
  p_box_pct_pixels$lt3+
    theme(
    plot.title = element_blank(),
    axis.title.x = element_blank(),
    axis.text.x= element_text(angle=90),
    # axis.text.y=element_blank() 
  )+
  p_box_pct_pixels$lt4+
    theme(
      plot.title = element_blank(),
      # plot.subtitle = element_text(),
    
    axis.title.x = element_blank(),
    axis.text.x= element_text(angle=90),
    axis.text.y=element_blank()
  )+
  plot_layout(ncol = 2,nrow=2)
````



```{r plot-ridge-box-missing-pixels}

p_ridge_pct_pixels <- df_country_pixel_stats %>%
  ggplot(aes(x=pct_pix, y= admin))+
  geom_density_ridges(fill=hdx_hex("mint-hdx"))+
  scale_x_continuous(labels = scales::label_percent())+
  labs(x="% Pixels Available",
       title= "IRI Seasonal Forecast",
       subtitle = "Missing Pixels in Central America")+
  theme(
    axis.title.y = element_blank()
  )


p_box_pct_pixels <- df_country_pixel_stats %>%
  ggplot(aes(x=pct_pix, y= admin))+
  geom_boxplot(width=0.25)+
  scale_x_continuous(labels = scales::label_percent())+
  labs(x="% Pixels Available")+
    theme(
    axis.title.y = element_blank()
  )


p_ridge_pct_pixels+
  p_box_pct_pixels+
  plot_layout(ncol = 2)
```

okay clearly there is an issue w/ dominant tercile probability missing pixels in this region. I can't find any documentation clearly explaining so let's see if we can figure it out.

```{r map-id-missing-pix}


library(leaflet)
# r_obj_ex<- raster::raster(r_dom_lt_split$lt1[[79]])
# r_obj_ex[is.na(r_obj_ex)]<-1000

m_4_draw <- tm_basemap(server = leaflet::providers$OpenStreetMap)+
  tm_shape(r_dom_lt_split$lt1[[79]])+
  tm_raster()


# I drew these points w/ `{mapedit}` and hardcoded using `dput()` like this:

# ml_4_draw <- tmap_leaflet(m_4_draw)
# pts_missing <- mapedit::drawFeatures(map =ml_4_draw )
# st_coordinates(pts_missing) %>% 
#   dput()


df_pts_missing <- data.frame(structure(c(-86.941185, -85.716667, -88.846602, 14.141615, 13.367872, 
                                         15.061327), dim = 3:2, dimnames = list(NULL, c("X", "Y"))))

gdf_pts_missing <- df_pts_missing %>% 
  mutate(
    id= row_number()
  ) %>% 
  st_as_sf(coords=c("X","Y"),crs=4326)

m_4_draw+
  tm_shape(
    gdf_pts_missing
  )+
  tm_markers()
```


Table below suggests that when 2 pixels values are tied as the dominant value (or close to it) the `Dominant` value goes to `NA` . This is probably documetned somewhere, but I could not find it.
```{r}
df_sampled_pixels_prob_dom_vals<- c(1:3) %>% 
  map2(.y=c("below_normal","normal", "above_normal"),
    \(ri,lb){
      r_prob_list$lt1[[ri]] %>% 
        set.names(dt_all_month)
      
      rp_t <- r_prob_list$lt1[[ri]][[79]]
      
      extract(x=rp_t, y=gdf_pts_missing) %>% 
        rename(
          !!sym(lb):= "2023-08-01"
        )
    }
  ) %>% 
  reduce(left_join,"ID") %>% 
  left_join(
    extract(x=r_dom_lt_split$lt1[[79]], y=gdf_pts_missing) %>% 
  rename(
    dom_tercile_prob="2023-08-01"
  )
  )
df_sampled_pixels_prob_dom_vals %>% 
  gt::gt()

  
```


## Probability Tercile Missing Pixels

Okay regardless, of the potential issue w/ `Dominant` missing pixels. The proposed framework is designed based on the probability of below average so let's check that out


Here we have a map showing total number of missing pixels across all months for the terciel probability of below average band (leadtime 1). The map doesn't change based on leadtime (not shown), indicating it is probably just certain pixels for a certain publication month

```{r}

r_bavg_missing_by_lt <- c("lt1", "lt2","lt3","lt4") %>% 
  map(\(lt){
    r_prob_bavg <- r_prob_list[[lt]][[1]]
    r_prob_bavg[!is.na(r_prob_bavg)]<-0
    r_prob_bavg[is.na(r_prob_bavg)]<-1
    return(sum(r_prob_bavg))
  }) %>% 
  set_names( c("lt1", "lt2","lt3","lt4"))

# hmm always the same missing..... so which is date is it?
plot(r_bavg_missing_by_lt$lt1)
plot(aoi_countries,add=T,col=NA)

```

Table below shows the dates and total number of missing pixels. It's all from one publication month

```{r}
dt_latest_month <- as_date("2023-08-01")
dt_earliest_month <- as_date("2023-08-01")-months(78)
dt_all_month <- seq(dt_earliest_month,dt_latest_month, by ="month") 
aoi_dissolved <- aoi_countries %>% 
  summarise()
# to find out i can just run zonal stats on binary na raster?
r_bavg_missing_by_lt <- c("lt1", "lt2","lt3","lt4") %>% 
  map_dfr(\(lt){
    r_prob_bavg <- r_prob_list[["lt1"]][[1]]
    r_prob_bavg[!is.na(r_prob_bavg)]<-0
    r_prob_bavg[is.na(r_prob_bavg)]<-1
    # set.names(r_prob_bavg,dt_all_month)
    exact_extract(
      x=r_prob_bavg,
      y=aoi_dissolved,
      fun= "sum") %>% 
    pivot_longer(cols = everything()) %>%
    separate(name, into = c("stat", "date"), sep = "\\.") %>%
    pivot_wider(names_from = "stat", values_from = "value") %>% 
      mutate(leadtime =lt)
  })

# confirmed
r_bavg_missing_by_lt %>% 
      filter(sum !=0) %>% 
  gt()
```

```{r, eval=F}
r_dom_bavg_missing_by_lt <- c("lt1", "lt2","lt3","lt4") %>% 
  map(\(lt){
    r_dom_bavg <- r_dom_lt_split[[lt]]
    r_dom_bavg[!is.na(r_dom_bavg)]<-0
    r_dom_bavg[is.na(r_dom_bavg)]<-1
    return(sum(r_dom_bavg))
  }) %>% 
  set_names( c("lt1", "lt2","lt3","lt4"))


# okay bigger problem for DOM for sure.
plot(r_dom_bavg_missing_by_lt$lt1)
plot(r_dom_bavg_missing_by_lt$lt2)
plot(r_dom_bavg_missing_by_lt$lt3)
plot(r_dom_bavg_missing_by_lt$lt4)
plot(aoi_countries,add=T,col=NA)
```




# Investigate Thresholds

## Probability Below Average Distributions

All Values
```{r}


df_prob_bavg_values <- r_prob_list %>% 
  imap_dfr(\(rt,nm){
    rt[[1]] %>% 
      terra::values() %>% 
      data.frame() %>% 
      pivot_longer(everything()) %>% 
      mutate(
        leadtime = str_replace(nm,"lt", "leadtime "),
        prob_cat = case_when(
          value <40~ "lt 40",
          value <50 ~"lt 50",
          value >=50 ~"gte 50")
      )
  }
  )

df_prob_bavg_values %>% 
  filter(!is.na(value)) %>% 
  group_by(leadtime,prob_cat) %>% 
  summarise(
    n_prob_cat =n(),.groups = "drop_last"
  ) %>% 
  mutate(
    pct_prob_cat = n_prob_cat/sum(n_prob_cat)
  )
df_prob_bavg_values%>% 
  mutate(
    value =value/100
  ) %>% 
  ggplot(
    aes(x=value, fill= prob_cat)
    )+
  geom_histogram(bins=100)+
  geom_vline(xintercept = c(.4,0.5),linetype="dashed", color=hdx_hex("tomato-hdx"))+
  scale_x_continuous(labels = scales::label_percent())+
       scale_fill_manual(
                                           values = c(`lt 40` = hdx_hex("sapphire-hdx"),
                                                      `lt 50` = hdx_hex("mint-hdx"),
                                                      `gte 50` = hdx_hex("tomato-hdx")
                                           
                                         ))+
  facet_wrap(~leadtime)+
  labs(
    title = "IRI Seasonal Forecast - Dry Corridor (Central America)",
    subtitle = "2017 - current: Probability of below average rainfall (value distribution)",
    x = "% probability below average "
         )+
  theme(
    legend.position  ="none"
    
  )


df_prob_bavg_values <- r_prob_list %>% 
  imap_dfr(\(rt,nm){
    rt[[1]] %>% 
      terra::values() %>% 
      data.frame() %>% 
      pivot_longer(everything()) %>% 
      mutate(
        leadtime = str_replace(nm,"lt", "leadtime "),
        prob_cat = case_when(
          value <40~ "lt 40",
          value <50 ~"lt 50",
          value >=50 ~"gte 50")
      )
  }
  )


```

By leadtime

```{r plot-histo-bavg-by-lt-and-phase}

df_prob_bavg_values <- r_prob_list %>% 
  imap_dfr(\(rt,nm){
    rt[[1]] %>% 
      terra::values() %>% 
      data.frame() %>% 
      pivot_longer(everything()) %>% 
      mutate(
        leadtime = str_replace(nm,"lt", "leadtime "),
        prob_cat = case_when(
          value <40~ "lt 40",
          value <50 ~"lt 50",
          value >=50 ~"gte 50")
      )
  }
  )

# this from up top - can de-duplciate later
dt_latest_month <- as_date("2023-08-01")
dt_earliest_month <- as_date("2023-08-01")-months(78)
dt_all_month <- seq(dt_earliest_month,dt_latest_month, by ="month") 

r_prob_bavg_labelled <- c(lt1=1, lt2=2,lt3=3, lt4=4) %>% 
  map(\(lt){
    r_prob_lt <- r_prob_list[[lt]][[1]] # below av
    month_seq <- dt_all_month+months(lt)
    end_dt = month_seq + months(3)
    start_mo  = str_sub(format(month_seq + months(1),"%b"),start = 1,end = 1)
    middle_mo  = str_sub(format(month_seq + months(2),"%b"),start = 1,end = 1)
    end_mo <- str_sub(format(month_seq + months(3),"%b"),start = 1,end = 1)
    end_yr <-  format(month_seq + months(3),"%y")
    seas_label <- paste0(start_mo, middle_mo, end_mo,end_yr)
    cat(seas_label,
        "\n")
    seas_label %>% length() %>% print()
    r_prob_lt %>% 
      set.names(seas_label)
    return(r_prob_lt)
    
    
  }
  )

df_prob_bavg_values_seas <- r_prob_bavg_labelled %>% 
  imap_dfr(\(rt,nm){
    rt %>% 
      terra::values() %>% 
      data.frame() %>% 
      pivot_longer(everything()) %>% 
      mutate(
        leadtime = str_replace(nm,"lt", "leadtime "),
        prob_cat = case_when(
          value <40~ "lt 40",
          value <50 ~"lt 50",
          value >=50 ~"gte 50")
      )
  }
  )
df_prob_bavg_values_seas %>% 
  count(name)

chr_window <- lst(window_1= "Window 1",window_2= "Window 2",window_3="Window 3") 
chr_window <- c("Window 1","Window 2","Window 3") 
chr_forecast_mo = c("MJJ","JJA","SON")
chr_subtitle = c("Primera Phase/Window 1 - Monitoring: January-March","Primera Phase/Window 2 - Monitoring: April-June","Postera Phase/Window 1 - Monitoring:July-Sept")
p_hist_bavg_prob_window_lt <-   pmap(.l = list(chr_window, chr_forecast_mo,chr_subtitle),
                                     .f = \(window_filt , mo_forecast, mo_monitor){
                                       df_prob_bavg_values_seas %>% 
                                         mutate(
                                           seas_cat_1 = case_when(
                                             str_detect(name,"^MJJ.*")~ "Window 1",
                                             str_detect(name,"^JJA.*")~ "Window 2",
                                             str_detect(name,"^SON.*")~ "Window 3",
                                             .default = "other"
                                           ),
                                           prob_cat = case_when(
                                             value <40~ "lt 40",
                                             value <50 ~"lt 50",
                                             value >=50 ~"gte 50")
                                           
                                         ) %>% 
                                         filter(seas_cat_1!="other") %>% 
                                         filter(
                                           seas_cat_1==window_filt
                                         ) %>% 
                                         mutate(
                                           value =value/100
                                         ) %>% 
                                         ggplot(
                                           aes(
                                             x=value,
                                             fill= prob_cat
                                           )
                                         )+
                                         geom_histogram(bins=100)+
                                         geom_vline(xintercept = c(.4,0.5),linetype="dashed", color=hdx_hex("tomato-hdx"))+
                                         scale_x_continuous(labels = scales::label_percent())+
                                         scale_fill_manual(
                                           values = c(`lt 40` = hdx_hex("sapphire-hdx"),
                                                      `lt 50` = hdx_hex("mint-hdx"),
                                                      `gte 50` = hdx_hex("tomato-hdx")
                                           
                                         ))+
                                         facet_wrap(~leadtime)+
                                         labs(
                                           title = glue("IRI Seasonal Forecast ({mo_forecast}) - below average rainfall probability"),
                                           subtitle = glue("Dry Corridor {mo_monitor}"),
                                           x = "% probability below average "
                                         )+
                                         theme(
                                           legend.position  ="none",
                                           plot.subtitle = element_text(size=10),
                                           plot.title  = element_text(size=10),
                                          axis.text.x = element_text(angle=90) 
                                         )
                                     }
  ) %>% 
  set_names(chr_window)
  
p_hist_bavg_prob_window_lt$`Window 1`+
  p_hist_bavg_prob_window_lt$`Window 2`+
  p_hist_bavg_prob_window_lt$`Window 3`+ 
  plot_layout(ncol = 3,nrow = 1)
  
  
```

## How many times would we trigger w/ 40 & 50 % thresholds
```{r}
tercile_mos <- r_prob_bavg_labelled %>% 
  map(~.x %>% names()) %>% 
  unlist() %>% 
  unique()

rgx_MJJ <-glue_collapse(str_subset(tercile_mos,"^MJJ"),"|")

r_mjj <- r_prob_bavg_labelled %>% 
  map(\(rt){
     rt[rgx_MJJ]
  }
  )


terra::values(r_mjj$lt1)
terra::values(r_mjj_copy)
thresh = c(10,20,30,40)[4]

c("lt1", "lt2","lt3","lt4") %>% 
  map_dfr(\(lt){
    rt <- r_mjj[[lt]]
    rt[rt<thresh]<-0
    rt[rt>=thresh]<-1
    rt[is.na(rt)]<-0
    exact_extract(
      x=rt,
      y=aoi_countries,
      append_cols = "admin",
      fun= "sum") %>% 
    pivot_longer(-admin )%>%
    separate(name, into = c("stat", "date"), sep = "\\.") %>% 
      mutate(
        leadtime =lt
      )
  }
  ) %>% 
  filter(value!=0)

```


## ZonL

## Zonal

```{r}

window_ids = c("MJJ","JJA","SON")
window_id_rgx <-glue_collapse(x = paste0("^",window_ids),"|")

df_bavg_zonal_adm0 <- r_prob_list %>% 
  imap_dfr(\(rt,nm){
    r_bavg <- rt[[1]] 
    # exact_extract(x=r_bavg,y = aoi_countries)
    exact_extract(x = r_bavg,
              y = aoi_countries,
              fun=c("mean","median"),
              append_cols ="admin") %>% 
      pivot_longer(-matches("admin")) %>%
      separate(name, into = c("stat", "date"), sep = "\\.") %>%
      pivot_wider(names_from = "stat", values_from = "value") %>% 
      mutate(
        leadtime = nm,
        seas_cat_1 = case_when(
          str_detect(date,"^MJJ.*")~ "Window 1",
          str_detect(date,"^JJA.*")~ "Window 2",
          str_detect(date,"^SON.*")~ "Window 3",
          .default = "other"
        ),
        seas_abbr = str_extract(date,window_id_rgx),
        seas_lab = glue("{seas_cat_1} ({seas_abbr})")
      )
  }
  ) 
  
df_bavg_zonal_adm0 %>% 
  filter(
    str_detect(date,window_id_rgx)
  ) %>% 
  ggplot(aes(x=median, fill=admin))+
  geom_histogram()+
  facet_wrap(~seas_cat_1)

df_bavg_zonal_adm0 %>% 
  filter(
    str_detect(date,window_id_rgx)
    ) %>% 
  
  ggplot(aes(x=admin, y=mean , fill =admin))+
  geom_boxplot()+
  geom_point(aes(color=leadtime))+
  facet_wrap(~seas_lab)

df_bavg_max_prob <- df_bavg_zonal_adm0 %>% 
  group_by(admin, season = date) %>% 
  summarise(
    across(c("mean","median"),~max(.x,na.r=T))
  ) %>% 
  filter(
    str_detect(season,window_id_rgx)
  ) %>% 
  mutate(
    yr = parse_number(season),
    mo_seas_start =case_when(
      str_detect(season, "^MJJ")~"03",
      str_detect(season, "^JJA")~"06",
      str_detect(season, "^SON")~"09"
    ),
    date_seas_start= ymd(paste0(yr,"-",mo_seas_start,"-01"))
  )

# mean probability plot

df_bavg_max_prob %>% 
  mutate(
    mean = mean/100
  ) %>% 
  ggplot(aes(x=date_seas_start,y=mean, color=admin))+
  geom_point()+
  geom_line()+
  scale_x_date(
    breaks = unique(df_bavg_max_prob$date_seas_start),date_labels = unique(df_bavg_max_prob$season)
    )+
  scale_y_continuous(
    breaks = seq(.15,.50, by =.05),labels = scales::label_percent(),limits = c(0.18,0.50)
    )+
  labs(x= "Season",
       y= "Mean Probability",
       title = "IRI Seasonal Forecast - Mean probability of below normal forecast per country",
       subtitle= "Month groupings from proposed trigger windows (window 1: MJJ, window 2: JJA, window 3: SON)"
       )+
  theme(
    axis.text.x = element_text(angle=90),
    legend.title = element_blank()
  )
  df_bavg_max_prob %>% 
    mutate(
    median = median/100
  ) %>% 
  ggplot(aes(x=date_seas_start,y=median, color=admin))+
  geom_point()+
  geom_line()+
  scale_x_date(
    breaks = unique(df_bavg_max_prob$date_seas_start),date_labels = unique(df_bavg_max_prob$season)
    )+
    scale_y_continuous(
    breaks = seq(.15,.50, by =.05),labels = scales::label_percent(),limits = c(0.18,0.50)
    )+
  labs(x= "Season",
       y= "Median Probability",
       title = "IRI Seasonal Forecast - Median probability of below normal forecast per country",
       subtitle= "Month groupings from proposed trigger windows (window 1: MJJ, window 2: JJA, window 3: SON)"
       )+
  theme(
    axis.text.x = element_text(angle=90),
    legend.title = element_blank()
  )


df_bavg_zonal_adm0 %>% 
  filter(
    str_detect(date,window_id_rgx)
    ) %>% 
  ggplot(aes(x=date,y=mean, color=admin,fill=admin))+
  geom_point()+
  theme(
    axis.text.x = element_text(angle=90)
  )
```

```{r}
country_pixel_stats <- r_dom_lt_split %>% 
  imap(\(rtemp,nm){
    exact_extract(x = rtemp,
              y = aoi_countries,
              fun="count",
              append_cols ="admin") %>% 
    pivot_longer(-matches("admin")) %>%
    separate(name, into = c("stat", "date"), sep = "\\.") %>%
    pivot_wider(names_from = "stat", values_from = "value") %>% 
    mutate(
      date_forecast_made= as_date(date)
    ) %>% 
  left_join(full_pixel_counts %>% 
              rename(total_pix =count)) %>% 
      mutate(
        pct_pix= count/total_pix,
        month = month(date,labe=T),
        pct_missing = 1- pct_pix,
        lt = parse_number(nm),
        date_predicted = date_forecast_made + months(lt),
        mo_pred = glue(
          "{month(date_predicted,label=T,abbr = T)}-{month(date_predicted+months(1),label=T,abbr = T)}-{month(date_predicted+months(2),label=T,abbr = T)}"
          )
      )
  }
  )
```

# Appendix

## Global

```{r}

dir_glb_iri <- file.path(
  Sys.getenv("AA_DATA_DIR"),
  "public",
  "raw",
  "glb",
  "iri") 



fp_glb_iri <- file.path(
  dir_iri,
  "IRI_20172023_clean.nc"
  )

tho_iri_glb <- tidync(fp_glb_iri)
  
iri_prob_global <- c(lt1=1,lt2=2,lt3=3,lt4=4) %>% 
  map(
     ~tho_iri_glb %>% 
  hyper_filter(
    L= L==.x
  )
  )

da_prob_global <- iri_prob_global %>% 
  map(
    ~.x %>% 
      hyper_array(select_var = "prob")
  )

da_prob_global$lt1$prob %>% dim()
r_prob_global <- da_prob_global %>% 
  map(
    \(da){
      da_reordered <- aperm(da[["prob"]],c(1,2,4,3))
      c(1:3) %>% 
        map(\(c_prob){
          da_c<- da_reordered[,,,c_prob] 
          rast(
            x= da_c,
            extent =ext(
              min(X_array$X),#-.5,
              max(X_array$X),#+.5,
              min(Y_array$Y),#-.5,
              max(Y_array$Y)#+.5
            ),
            crs= "EPSG:4326")
           
        }
        )
    }
  )

```
