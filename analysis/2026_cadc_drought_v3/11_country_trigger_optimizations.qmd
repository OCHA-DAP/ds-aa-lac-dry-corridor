# Trigger Configuration: HND & SLV {#sec-trigger-config}

```{r}
#| label: setup-trigger-config
#| include: false

library(tidyverse)
library(lubridate)
library(cumulus)
library(gt)
library(janitor)
library(ggrepel)
library(ggiraph)

box::purge_cache()
box::use(
  ../../R/country_trigger_optimization[...],
  ../../R/trigger_viz[...]
)

knitr::opts_chunk$set(
  echo = FALSE,
  warning = FALSE,
  message = FALSE
)
```

## Overview

@sec-honduras-trigger developed a purely rainfall-based trigger optimization for Honduras, defining drought as the N driest ERA5 years (matched return period). This chapter takes a different approach: we begin with **humanitarian impact data** to identify which years *must* be triggered, then layer in ERA5 rainfall skill to select the final configuration

The key insight motivating this approach is that seasonal rainfall forecasts are an imperfect proxy for drought impact. EM-DAT records and CERF allocations provide direct evidence of when humanitarian consequences occurred. Rather than optimizing solely against observed rainfall, we first ensure our trigger catches the most consequential events, then optimize for rainfall prediction accuracy among configurations that meet that constraint.

This chapter covers Honduras, El Salvador, and Guatemala. For Guatemala, we evaluate two separate areas of interest: the standard OCHA AOI (Chiquimula and Alta Verapaz) and the StartNetwork AOI (Quiché and Baja Verapaz).


```{r}
#| label: load-impact-data

iso_lookup <- c(HND = "Honduras", GTM = "Guatemala", SLV = "El Salvador")

df_cerf <- cumulus::load_cerf_from_blob() |> clean_names()
df_emdat <- cumulus::load_emdat_from_blob() |> clean_names()

# CERF drought allocations
df_cerf_drought <- df_cerf |>
  filter(
    country_code %in% names(iso_lookup),
    window_full_name == "Rapid Response",
    emergency_type_name == "Drought"
  ) |>
  mutate(year = year(date_usg_signature)) |>
  distinct(iso3 = country_code, year)

# CERF Hypothesis:
# 2016 is a late drought response — allocations in 2016 associated with
# the 2-year drought in 2014-2015.
# 2019 is a late response associated with the 2018 drought.
# 2025 excluded as an outlier.
cerf_start_drought_years <- c("2018", "2015", "2014", "2009")

# EM-DAT with total_affected (for validation table)
df_emdat_drought <- df_emdat |>
  filter(
    iso %in% names(iso_lookup),
    disaster_type == "Drought"
  ) |>
  group_by(iso3 = iso, year = start_year) |>
  summarise(total_affected = sum(total_affected, na.rm = TRUE), .groups = "drop")

# EM-DAT interpolated: spread total_affected evenly across start_year:end_year
df_emdat_drought_interp <- df_emdat |>
  filter(
    iso %in% names(iso_lookup),
    disaster_type == "Drought"
  ) |>
  mutate(
    end_yr = if_else(is.na(end_year), start_year, end_year),
    n_event_years = end_yr - start_year + 1,
    affected_per_year = total_affected / n_event_years
  ) |>
  rowwise() |>
  mutate(year = list(seq(start_year, end_yr))) |>
  tidyr::unnest(year) |>
  ungroup() |>
  group_by(iso3 = iso, year) |>
  summarise(total_affected_interp = sum(affected_per_year, na.rm = TRUE), .groups = "drop")

# EM-DAT distinct impact years (expanded across multi-year events)
df_emdat_impact <- df_emdat |>
  filter(
    iso %in% names(iso_lookup),
    disaster_type == "Drought"
  ) |>
  mutate(end_yr = if_else(is.na(end_year), start_year, end_year)) |>
  rowwise() |>
  mutate(year = list(seq(start_year, end_yr))) |>
  tidyr::unnest(year) |>
  ungroup() |>
  distinct(iso3 = iso, year)

EVAL_START <- 1991
EVAL_END <- 2024
BASELINE_START <- 1991
BASELINE_END <- 2024
MAX_RP <- 20

# Per-country impact years
impact_by_country <- split(
  df_emdat_impact |> filter(year >= EVAL_START, year <= EVAL_END),
  df_emdat_impact |> filter(year >= EVAL_START, year <= EVAL_END) |> pull(iso3)
)

# Cross-country overlap
impact_year_counts <- df_emdat_impact |>
  filter(year >= EVAL_START, year <= EVAL_END) |>
  count(year) |>
  arrange(desc(n), year)

# Priority year definitions
cerf_hyp_years <- as.integer(cerf_start_drought_years)
all3_years <- impact_year_counts |> filter(n == 3) |> pull(year)
must_hit_years <- cerf_hyp_years
should_hit_years <- setdiff(all3_years, cerf_hyp_years)
```

## Impact Data Landscape

Before defining trigger thresholds, we examine the historical record of drought impacts across the dry corridor. From this evidence we define two priority classes for the trigger optimization:

- **Priority 1 (must-hit)**: The CERF hypothesis years --- `r paste(sort(must_hit_years), collapse = ", ")`. These are the years where CERF actually allocated drought funding (adjusted for delayed response timing). They represent donor-validated humanitarian crises where we have the strongest obligation to trigger.

- **Priority 2 (should-hit)**: Years where all 3 countries appear in EM-DAT expanded drought records but are not CERF hypothesis years --- `r paste(sort(should_hit_years), collapse = ", ")`. Regional consensus across all three countries indicates widespread drought conditions, even without CERF activation.

@tbl-impact-summary shows the full landscape of CERF allocations, EM-DAT entries (both as-reported and expanded across multi-year events), and the resulting priority classification for `r EVAL_START`--`r EVAL_END`.

```{r}
#| label: tbl-impact-summary
#| tbl-cap: "Impact data summary across CERF, EM-DAT, and CERF hypothesis years. Priority 1 (pink) = CERF hypothesis drought years. Priority 2 (yellow) = years where all 3 countries appear in EM-DAT expanded."

impact_summary_years <- EVAL_START:EVAL_END

cerf_by_iso <- df_cerf_drought |>
  filter(year >= EVAL_START, year <= EVAL_END) |>
  distinct(iso3, year) |>
  mutate(val = TRUE) |>
  pivot_wider(names_from = iso3, values_from = val, names_prefix = "cerf_") |>
  complete(year = impact_summary_years)

emdat_reported <- df_emdat_drought |>
  filter(year >= EVAL_START, year <= EVAL_END) |>
  distinct(iso3, year) |>
  mutate(val = TRUE) |>
  pivot_wider(names_from = iso3, values_from = val, names_prefix = "emdat_") |>
  complete(year = impact_summary_years)

emdat_expanded <- df_emdat_impact |>
  filter(year >= EVAL_START, year <= EVAL_END) |>
  distinct(iso3, year) |>
  mutate(val = TRUE) |>
  pivot_wider(names_from = iso3, values_from = val, names_prefix = "emdat_exp_") |>
  complete(year = impact_summary_years)

cerf_hyp <- tibble(year = cerf_hyp_years, cerf_hypothesis = TRUE)

impact_summary <- tibble(year = impact_summary_years) |>
  left_join(cerf_by_iso, by = "year") |>
  left_join(emdat_reported, by = "year") |>
  left_join(emdat_expanded, by = "year") |>
  left_join(cerf_hyp, by = "year") |>
  mutate(across(-year, ~ if_else(replace_na(.x, FALSE), "\u2713", ""))) |>
  mutate(
    hit_priority = case_when(
      year %in% cerf_hyp_years ~ 1L,
      year %in% all3_years     ~ 2L,
      TRUE ~ NA_integer_
    )
  )

tick_cols <- c("cerf_HND", "cerf_GTM", "cerf_SLV",
               "emdat_HND", "emdat_GTM", "emdat_SLV",
               "emdat_exp_HND", "emdat_exp_GTM", "emdat_exp_SLV",
               "cerf_hypothesis")

impact_summary |>
  gt() |>
  cols_label(
    year = "Year",
    cerf_HND = "HND", cerf_GTM = "GTM", cerf_SLV = "SLV",
    emdat_HND = "HND", emdat_GTM = "GTM", emdat_SLV = "SLV",
    emdat_exp_HND = "HND", emdat_exp_GTM = "GTM", emdat_exp_SLV = "SLV",
    cerf_hypothesis = "Hypothesis",
    hit_priority = "Priority"
  ) |>
  cols_move(columns = cerf_hypothesis, after = cerf_SLV) |>
  tab_spanner(label = "CERF", columns = c(cerf_HND, cerf_GTM, cerf_SLV, cerf_hypothesis)) |>
  tab_spanner(label = "EM-DAT (reported)", columns = c(emdat_HND, emdat_GTM, emdat_SLV)) |>
  tab_spanner(label = "EM-DAT (expanded)", columns = c(emdat_exp_HND, emdat_exp_GTM, emdat_exp_SLV)) |>
  cols_align(align = "center", columns = -year) |>
  sub_missing(columns = hit_priority, missing_text = "") |>
  tab_style(
    style = cell_fill(color = "#d4edda"),
    locations = cells_body(columns = all_of(tick_cols), rows = TRUE)
  ) |>
  tab_style(style = cell_fill(color = "white"),
    locations = cells_body(columns = cerf_HND, rows = cerf_HND == "")) |>
  tab_style(style = cell_fill(color = "white"),
    locations = cells_body(columns = cerf_GTM, rows = cerf_GTM == "")) |>
  tab_style(style = cell_fill(color = "white"),
    locations = cells_body(columns = cerf_SLV, rows = cerf_SLV == "")) |>
  # EM-DAT (reported): muted — light grey fill + faded text for entire column
  tab_style(
    style = list(cell_fill(color = "#f0f0f0"), cell_text(color = "#999999")),
    locations = list(
      cells_body(columns = c(emdat_HND, emdat_GTM, emdat_SLV)),
      cells_column_labels(columns = c(emdat_HND, emdat_GTM, emdat_SLV)),
      cells_column_spanners(spanners = "EM-DAT (reported)")
    )
  ) |>
  tab_style(style = cell_fill(color = "white"),
    locations = cells_body(columns = emdat_exp_HND, rows = emdat_exp_HND == "")) |>
  tab_style(style = cell_fill(color = "white"),
    locations = cells_body(columns = emdat_exp_GTM, rows = emdat_exp_GTM == "")) |>
  tab_style(style = cell_fill(color = "white"),
    locations = cells_body(columns = emdat_exp_SLV, rows = emdat_exp_SLV == "")) |>
  tab_style(style = cell_fill(color = "white"),
    locations = cells_body(columns = cerf_hypothesis, rows = cerf_hypothesis == "")) |>
  tab_style(style = cell_fill(color = "#fde0dd"),
    locations = cells_body(columns = hit_priority, rows = hit_priority == 1)) |>
  tab_style(style = cell_fill(color = "#fff7bc"),
    locations = cells_body(columns = hit_priority, rows = hit_priority == 2)) |>
  # Vertical dividers between spanner groups
  tab_style(
    style = cell_borders(sides = "left", color = "#666666", weight = px(2)),
    locations = list(
      cells_body(columns = cerf_HND),
      cells_column_labels(columns = cerf_HND),
      cells_column_spanners(spanners = "CERF")
    )
  ) |>
  tab_style(
    style = cell_borders(sides = "left", color = "#666666", weight = px(2)),
    locations = list(
      cells_body(columns = emdat_HND),
      cells_column_labels(columns = emdat_HND),
      cells_column_spanners(spanners = "EM-DAT (reported)")
    )
  ) |>
  tab_style(
    style = cell_borders(sides = "left", color = "#666666", weight = px(2)),
    locations = list(
      cells_body(columns = emdat_exp_HND),
      cells_column_labels(columns = emdat_exp_HND),
      cells_column_spanners(spanners = "EM-DAT (expanded)")
    )
  ) |>
  tab_style(
    style = cell_borders(sides = "left", color = "#666666", weight = px(2)),
    locations = list(
      cells_body(columns = hit_priority),
      cells_column_labels(columns = hit_priority)
    )
  ) |>
  tab_header(
    title = "Impact Data Summary (CERF, EM-DAT, CERF Hypothesis)",
    subtitle = sprintf(
      "%d\u2013%d | Priority 1 = CERF hypothesis | Priority 2 = 3/3 countries EM-DAT expanded",
      EVAL_START, EVAL_END)
  ) |>
  opt_stylize(style = 1)
```


## Rainfall vs Impact Alignment

A key question is whether seasonal rainfall alone can predict humanitarian impact. The tables below show per-country validation: for each year, we compare ERA5 observed rainfall ranking with CERF allocations, EM-DAT records, and total affected population.

```{r}
#| label: load-country-data
#| cache: true

countries <- list(
  HND = list(
    aoi_pcodes = c("HN07", "HN08"),
    primera_months = 5:8,
    postrera_months = 9:11,
    primera_issued_months = c(3, 4, 5),
    postrera_issued_months = c(6, 7, 8, 9)
  ),
  GTM = list(
    aoi_pcodes = c("GT20", "GT16"),
    primera_months = 5:8,
    postrera_months = 9:11,
    primera_issued_months = c(3, 4, 5),
    postrera_issued_months = c(6, 7, 8, 9)
  ),
  SLV = list(
    iso3 = "SLV",
    adm_level = 0,
    primera_months = 5:8,
    postrera_months = 9:11,
    primera_issued_months = c(3, 4, 5),
    postrera_issued_months = c(6, 7, 8, 9)
  ),
  GTM_SN = list(
    aoi_pcodes = c("GT14", "GT15"),
    primera_months = 5:8,
    postrera_months = 9:11,
    primera_issued_months = c(3, 4, 5),
    postrera_issued_months = c(6, 7, 8, 9)
  )
)

load_country_data <- function(cfg) {
  con <- pg_con()
  on.exit(DBI::dbDisconnect(con))

  use_adm0 <- isTRUE(cfg$adm_level == 0)

  if (use_adm0) {
    df_seas5_raw <- tbl(con, "seas5") |>
      filter(iso3 == cfg$iso3, adm_level == 0) |> collect()
    df_era5_raw <- tbl(con, "era5") |>
      filter(iso3 == cfg$iso3, adm_level == 0) |> collect()
  } else {
    df_seas5_raw <- tbl(con, "seas5") |>
      mutate(across(pcode, as.character)) |>
      filter(adm_level == 1, pcode %in% cfg$aoi_pcodes) |> collect()
    df_era5_raw <- tbl(con, "era5") |>
      mutate(across(pcode, as.character)) |>
      filter(pcode %in% cfg$aoi_pcodes) |> collect()
  }

  df_seas5_mm <- df_seas5_raw |>
    mutate(value_mm = days_in_month(valid_date) * mean)

  if (use_adm0) {
    df_seas5_seasonal <- bind_rows(
      seas5_aggregate_forecast(df_seas5_mm, value = "value_mm",
        valid_months = cfg$primera_months, by = c("iso3", "issued_date")
      ) |> mutate(window = "primera"),
      seas5_aggregate_forecast(df_seas5_mm, value = "value_mm",
        valid_months = cfg$postrera_months, by = c("iso3", "issued_date")
      ) |> mutate(window = "postrera")
    ) |>
      rename(fcst_mm = value_mm) |>
      mutate(year = year(issued_date), issued_month = month(issued_date)) |>
      filter(
        (window == "primera" & issued_month %in% cfg$primera_issued_months) |
        (window == "postrera" & issued_month %in% cfg$postrera_issued_months)
      )

    df_era5_monthly <- df_era5_raw |>
      mutate(year = year(valid_date), month = month(valid_date),
             value_mm = mean * days_in_month(valid_date))

    df_era5_seasonal <- bind_rows(
      df_era5_monthly |> filter(month %in% cfg$primera_months) |>
        group_by(iso3, year) |>
        summarise(obs_mm = sum(value_mm), .groups = "drop") |>
        mutate(window = "primera"),
      df_era5_monthly |> filter(month %in% cfg$postrera_months) |>
        group_by(iso3, year) |>
        summarise(obs_mm = sum(value_mm), .groups = "drop") |>
        mutate(window = "postrera")
    )

    df_joined <- df_seas5_seasonal |>
      left_join(df_era5_seasonal |> select(iso3, year, window, obs_mm),
                by = c("iso3", "year", "window")) |>
      filter(!is.na(obs_mm)) |>
      group_by(year, window, leadtime) |>
      summarise(fcst_mm = mean(fcst_mm), obs_mm = mean(obs_mm), .groups = "drop") |>
      filter(year >= BASELINE_START, year <= BASELINE_END)
  } else {
    df_weights <- tbl(con, "polygon") |>
      mutate(across(pcode, as.character)) |>
      filter(adm_level == 1, pcode %in% cfg$aoi_pcodes) |>
      select(pcode, seas5_n_upsampled_pixels) |> collect()

    df_seas5_seasonal <- bind_rows(
      seas5_aggregate_forecast(df_seas5_mm, value = "value_mm",
        valid_months = cfg$primera_months, by = c("iso3", "pcode", "issued_date")
      ) |> mutate(window = "primera"),
      seas5_aggregate_forecast(df_seas5_mm, value = "value_mm",
        valid_months = cfg$postrera_months, by = c("iso3", "pcode", "issued_date")
      ) |> mutate(window = "postrera")
    ) |>
      rename(fcst_mm = value_mm) |>
      mutate(year = year(issued_date), issued_month = month(issued_date)) |>
      filter(
        (window == "primera" & issued_month %in% cfg$primera_issued_months) |
        (window == "postrera" & issued_month %in% cfg$postrera_issued_months)
      )

    df_era5_monthly <- df_era5_raw |>
      mutate(year = year(valid_date), month = month(valid_date),
             value_mm = mean * days_in_month(valid_date))

    df_era5_seasonal <- bind_rows(
      df_era5_monthly |> filter(month %in% cfg$primera_months) |>
        group_by(pcode, iso3, year) |>
        summarise(obs_mm = sum(value_mm), .groups = "drop") |>
        mutate(window = "primera"),
      df_era5_monthly |> filter(month %in% cfg$postrera_months) |>
        group_by(pcode, iso3, year) |>
        summarise(obs_mm = sum(value_mm), .groups = "drop") |>
        mutate(window = "postrera")
    )

    df_joined <- df_seas5_seasonal |>
      left_join(df_era5_seasonal |> select(pcode, year, window, obs_mm),
                by = c("pcode", "year", "window")) |>
      filter(!is.na(obs_mm)) |>
      left_join(df_weights, by = "pcode") |>
      group_by(year, window, leadtime) |>
      summarise(
        fcst_mm = weighted.mean(fcst_mm, w = seas5_n_upsampled_pixels),
        obs_mm  = weighted.mean(obs_mm,  w = seas5_n_upsampled_pixels),
        .groups = "drop"
      ) |>
      filter(year >= BASELINE_START, year <= BASELINE_END)
  }

  df_joined |>
    group_by(window) |>
    mutate(leadtime = leadtime - min(leadtime)) |>
    ungroup()
}

df_hnd <- load_country_data(countries$HND)
df_gtm <- load_country_data(countries$GTM)
df_slv <- load_country_data(countries$SLV)
df_gtm_sn <- load_country_data(countries$GTM_SN)
```

The validation tables below cross-reference each year's primera and postrera rainfall dry rank with CERF allocations, EM-DAT records, and total affected population. Years are sorted by maximum seasonal dryness rank so the most extreme rainfall years appear first. A mismatch between dry rank and impact columns indicates that rainfall alone is not a reliable predictor of humanitarian consequences.

::: {.panel-tabset}

### Honduras

```{r}
#| label: tbl-validation-hnd
build_impact_validation_gt(df_hnd, df_cerf_drought, df_emdat_drought, "HND",
                           eval_start = EVAL_START, eval_end = EVAL_END,
                           df_emdat_interp = df_emdat_drought_interp,
                           cerf_hypothesis_years = cerf_hyp_years,
                           sort_by = "max_rp")
```

### El Salvador

```{r}
#| label: tbl-validation-slv
build_impact_validation_gt(df_slv, df_cerf_drought, df_emdat_drought, "SLV",
                           eval_start = EVAL_START, eval_end = EVAL_END,
                           df_emdat_interp = df_emdat_drought_interp,
                           cerf_hypothesis_years = cerf_hyp_years,
                           sort_by = "max_rp")
```

### Guatemala

```{r}
#| label: tbl-validation-gtm
build_impact_validation_gt(df_gtm, df_cerf_drought, df_emdat_drought, "GTM",
                           eval_start = EVAL_START, eval_end = EVAL_END,
                           df_emdat_interp = df_emdat_drought_interp,
                           cerf_hypothesis_years = cerf_hyp_years,
                           sort_by = "max_rp")
```

### Guatemala (StartNetwork)

```{r}
#| label: tbl-validation-gtmsn
build_impact_validation_gt(df_gtm_sn, df_cerf_drought, df_emdat_drought, "GTM",
                           eval_start = EVAL_START, eval_end = EVAL_END,
                           df_emdat_interp = df_emdat_drought_interp,
                           cerf_hypothesis_years = cerf_hyp_years,
                           sort_by = "max_rp")
```

:::

These tables demonstrate a recurring pattern: some of the most impactful drought years (e.g. those with CERF allocations or high total affected) do not always coincide with the driest rainfall years, and vice versa. This imperfect correlation between rainfall and impact is the primary motivation for our hybrid optimization approach.


## Optimization Strategy

Given that rainfall is an imperfect predictor of humanitarian impact, we adopt a staged optimization that prioritizes impact evidence first, then maximizes rainfall prediction skill:

1. **Impact-first filtering**: Evaluate all threshold configurations against EM-DAT impact years using standard F1. Keep only configs that trigger in all Priority 1 years (must-hit). Among those, keep configs with the maximum Priority 2 hits (should-hit).

2. **ERA5 rainfall evaluation**: For the surviving candidate pool, evaluate against ERA5 observed rainfall using the tolerant matched-RP F1 from @sec-honduras-trigger. This tells us how well each config predicts actual rainfall anomalies, independent of the impact definition.

3. **Combined selection**: Plot impact F1 against ERA5 tolerant F1 to visualize the tradeoff. Compute an average of both F1 scores and identify the best-performing config at each return period level. Among tied configs, select the one with the lowest threshold coefficient of variation (most operationally uniform thresholds).

The rationale is straightforward: since SEAS5 forecasts are our only trigger variable, and they predict rainfall rather than impact directly, it makes sense to first ensure we capture the most consequential events (via impact filtering), then optimize for what the forecast actually predicts well (rainfall). After the priority-hit filters are satisfied, a high ERA5 tolerant F1 indicates the trigger is selecting genuinely dry years rather than succeeding on impact years by coincidence.


```{r}
#| label: helper-uniform-refs

# Helper: get uniform reference configs from the pre-filter pool.
# This bypasses must-hit/should-hit filtering so we can see the full range
# of uniform RPs (strict uniform configs often fail must-hit and disappear).
get_uniform_refs_prefilter <- function(all_results, threshold_cols,
                                       primera_lts, postrera_lts,
                                       target_rp, era5_data = NULL) {
  # All uniform configs from pre-filter pool
  uniform_pool <- all_results |>
    filter(p_lt_count == primera_lts, s_lt_count == postrera_lts) |>
    filter(all_cv == 0) |>
    distinct(across(all_of(threshold_cols)), .keep_all = TRUE)

  if (nrow(uniform_pool) == 0) {
    message("  No uniform configs found in pre-filter pool")
    return(tibble())
  }

  u_rps <- sort(unique(uniform_pool$annual_rp))
  message(sprintf("  Uniform RPs (all pre-filter): %s", paste(round(u_rps, 2), collapse = ", ")))

  # Show all uniform configs — there are few (one per grid point)
  ref <- uniform_pool |>
    mutate(
      impact_f1 = mean_f1,
      option = "U", selection = "uniform",
      config_label = sprintf("RP %.1f\n(Uniform thresh %.1f)",
                             annual_rp, .data[[threshold_cols[1]]])
    )

  # Keep only the columns needed for bind_rows with the A/B options
  ref <- ref |>
    select(all_of(threshold_cols), impact_f1, annual_rp,
           p_seasonal_rp, s_seasonal_rp, mean_cv, all_cv,
           must_hit_score, should_hit_score,
           option, selection, config_label)

  # Left-join ERA5 data if available; fallback to impact_f1
  if (!is.null(era5_data) && nrow(era5_data) > 0) {
    ref <- ref |>
      left_join(
        era5_data |>
          select(all_of(threshold_cols), era5_tol_f1 = mean_tol_f1,
                 era5_p_tol_tp = primera_tol_tp, era5_p_tol_fp = primera_tol_fp, era5_p_tol_fn = primera_tol_fn,
                 era5_s_tol_tp = postrera_tol_tp, era5_s_tol_fp = postrera_tol_fp, era5_s_tol_fn = postrera_tol_fn),
        by = threshold_cols
      ) |>
      mutate(
        era5_tol_f1 = if_else(is.na(era5_tol_f1), impact_f1, era5_tol_f1),
        avg_f1 = (impact_f1 + era5_tol_f1) / 2
      )
  } else {
    ref <- ref |>
      mutate(era5_tol_f1 = impact_f1, avg_f1 = impact_f1)
  }

  ref
}

# Helper: build a compact config summary gt table with optional green highlighting
build_config_summary_gt <- function(df_final, threshold_cols,
                                     primera_lts, postrera_lts,
                                     country_name, top_picks = NULL) {
  p_cols <- threshold_cols[startsWith(threshold_cols, "p")]
  s_cols <- threshold_cols[startsWith(threshold_cols, "s")]

  # Format primera thresholds
  fmt_lts <- function(row, cols) {
    vals <- sapply(cols, function(c) {
      v <- row[[c]]
      if (is.na(v)) return(NA_character_)
      sprintf("%.1f", v)
    })
    vals <- vals[!is.na(vals)]
    paste(sprintf("LT%d: %s", seq_along(vals) - 1, vals), collapse = " | ")
  }

  tbl_df <- df_final |>
    rowwise() |>
    mutate(
      primera_thresholds = fmt_lts(cur_data(), p_cols),
      postrera_thresholds = fmt_lts(cur_data(), s_cols),
      config_label_clean = gsub("\n", " ", config_label)
    ) |>
    ungroup()

  # Deduplicate: when A/B and uniform rows share identical thresholds,

  # keep the A/B row and annotate it as also uniform
  uniform_thresh <- tbl_df |>
    filter(option == "U") |>
    select(all_of(threshold_cols))
  if (nrow(uniform_thresh) > 0) {
    tbl_df <- tbl_df |>
      mutate(has_uniform_dup = option != "U" & {
        sapply(row_number(), function(i) {
          any(apply(uniform_thresh, 1, function(u_row) {
            all(sapply(threshold_cols, function(col) {
              isTRUE(all.equal(tbl_df[[col]][i], u_row[[col]]))
            }))
          }))
        })
      }) |>
      mutate(config_label_clean = if_else(
        has_uniform_dup,
        paste0(config_label_clean, " (uniform)"),
        config_label_clean
      ))
    # Remove uniform rows that are duplicated by an A/B row
    dup_uniform <- tbl_df |>
      filter(option == "U") |>
      semi_join(
        tbl_df |> filter(has_uniform_dup),
        by = threshold_cols
      ) |>
      pull(row_idx)
    tbl_df <- tbl_df |>
      filter(!(row_idx %in% dup_uniform)) |>
      select(-has_uniform_dup)
  }

  # Flag top picks
  if (!is.null(top_picks)) {
    tbl_df <- tbl_df |>
      mutate(is_top = sapply(config_label_clean, function(lbl) {
        any(sapply(top_picks, function(pat) grepl(pat, lbl, fixed = TRUE)))
      }))
  } else {
    tbl_df <- tbl_df |> mutate(is_top = FALSE)
  }

  # Sort: top picks first, then by annual_rp
  tbl_df <- tbl_df |>
    arrange(desc(is_top), annual_rp)

  display_df <- tbl_df |>
    mutate(row_num = row_number()) |>
    select(row_num, config_label_clean, annual_rp, p_seasonal_rp, s_seasonal_rp,
           primera_thresholds, postrera_thresholds, is_top) |>
    mutate(
      annual_rp = round(annual_rp, 2),
      p_seasonal_rp = round(p_seasonal_rp, 2),
      s_seasonal_rp = round(s_seasonal_rp, 2)
    )

  top_rows <- which(display_df$is_top)

  gt_tbl <- display_df |>
    select(-is_top) |>
    gt() |>
    cols_label(
      row_num = "#",
      config_label_clean = "Config",
      annual_rp = "Annual RP",
      p_seasonal_rp = "Primera RP",
      s_seasonal_rp = "Postrera RP",
      primera_thresholds = "Primera Thresholds",
      postrera_thresholds = "Postrera Thresholds"
    ) |>
    cols_align(align = "center") |>
    cols_align(align = "left", columns = c(primera_thresholds, postrera_thresholds)) |>
    tab_header(title = sprintf("%s: Configuration Summary", country_name))

  if (length(top_rows) > 0) {
    gt_tbl <- gt_tbl |>
      tab_style(
        style = list(cell_fill(color = "#d4edda"), cell_text(weight = "bold")),
        locations = cells_body(rows = top_rows)
      )
  }

  gt_tbl |>
    tab_options(
      table.font.size = px(12),
      data_row.padding = px(4),
      column_labels.font.weight = "bold",
      heading.align = "left"
    ) |>
    tab_style(
      style = cell_text(font = system_fonts("monospace-code"), size = px(11)),
      locations = cells_body(columns = c(primera_thresholds, postrera_thresholds))
    )
}

# Helper: build a topline performance table for top-pick configs
# Shows 3 validation tiers: P1 (CERF), P2 (regional), EM-DAT confusion matrix + ERA5 F1
build_topline_gt <- function(df_final, top_picks, trigger_data,
                              impact_yrs, must_hit_yrs, should_hit_yrs,
                              eval_start, eval_end, country_name) {
  # Filter to top picks
  top_df <- df_final |>
    mutate(label_clean = gsub("\n", " ", config_label)) |>
    filter(sapply(label_clean, function(lbl) {
      any(sapply(top_picks, function(pat) grepl(pat, lbl, fixed = TRUE)))
    }))

  if (nrow(top_df) == 0) return(NULL)

  n_p1 <- length(must_hit_yrs)
  n_p2 <- length(should_hit_yrs)

  # First pass: collect trigger years per config to find universal years
  all_activations <- lapply(seq_len(nrow(top_df)), function(i) {
    act <- get_seasonal_activation(top_df[i, ], trigger_data, eval_start, eval_end)
    sort(union(act$primera, act$postrera))
  })
  universal_yrs <- Reduce(intersect, all_activations)

  rows <- lapply(seq_len(nrow(top_df)), function(i) {
    r <- top_df[i, ]
    act <- get_seasonal_activation(r, trigger_data, eval_start, eval_end)
    trigger_yrs <- sort(union(act$primera, act$postrera))
    tp <- length(intersect(trigger_yrs, impact_yrs))
    fp <- length(setdiff(trigger_yrs, impact_yrs))
    fn <- length(setdiff(impact_yrs, trigger_yrs))
    p1_caught <- length(intersect(trigger_yrs, must_hit_yrs))
    p2_caught <- length(intersect(trigger_yrs, should_hit_yrs))
    # ERA5 tolerant confusion matrix (sum of primera + postrera per-season counts)
    na0 <- function(x) if (is.null(x) || is.na(x)) 0L else as.integer(x)
    era5_tp <- na0(r$era5_p_tol_tp) + na0(r$era5_s_tol_tp)
    era5_fp <- na0(r$era5_p_tol_fp) + na0(r$era5_s_tol_fp)
    era5_fn <- na0(r$era5_p_tol_fn) + na0(r$era5_s_tol_fn)
    n_years <- eval_end - eval_start + 1
    emdat_tn <- n_years - tp - fp - fn
    emdat_f1 <- if (tp + fp + fn > 0) round(2 * tp / (2 * tp + fp + fn), 3) else 0
    era5_tn <- era5_tp + era5_fp + era5_fn  # per-season total; TN = 2*N - total
    # Each season has n_years obs, so total possible = 2 * n_years
    era5_tn <- 2L * n_years - era5_tp - era5_fp - era5_fn
    # Build HTML year badges: red outline if year doesn't fire for all configs
    p_only <- setdiff(act$primera, act$postrera)
    s_only <- setdiff(act$postrera, act$primera)
    both <- intersect(act$primera, act$postrera)
    yr_spans <- vapply(sort(trigger_yrs), function(yr) {
      cls <- if (yr %in% both) "yr-b" else if (yr %in% p_only) "yr-p" else "yr-s"
      if (!(yr %in% universal_yrs)) cls <- paste(cls, "yr-notall")
      sprintf('<span class="%s">%d</span>', cls, yr)
    }, character(1))
    years_fired <- paste(yr_spans, collapse = " ")

    tibble(
      config = r$label_clean,
      annual_rp = round(r$annual_rp, 2),
      p1 = sprintf("%d/%d", p1_caught, n_p1),
      p2 = sprintf("%d/%d", p2_caught, n_p2),
      emdat_tp = tp,
      emdat_fp = fp,
      emdat_fn = fn,
      emdat_tn = emdat_tn,
      emdat_f1 = emdat_f1,
      era5_tp = era5_tp,
      era5_fp = era5_fp,
      era5_fn = era5_fn,
      era5_tn = era5_tn,
      era5_tol_f1 = round(r$era5_tol_f1, 3),
      years_fired = years_fired
    )
  })
  tbl_df <- bind_rows(rows)
  # Convert years_fired to list of html() objects so gt renders without escaping
  tbl_df$years_fired <- lapply(tbl_df$years_fired, gt::html)

  tbl_df |>
    gt() |>
    cols_label(
      config = "Config",
      annual_rp = "Annual RP",
      p1 = "P1 Caught",
      p2 = "P2 Caught",
      emdat_tp = "TP",
      emdat_fp = "FP",
      emdat_fn = "FN",
      emdat_tn = "TN",
      emdat_f1 = "F1",
      era5_tp = "TP",
      era5_fp = "FP",
      era5_fn = "FN",
      era5_tn = "TN",
      era5_tol_f1 = "F1",
      years_fired = "Years Fired"
    ) |>
    cols_align(align = "center") |>
    cols_align(align = "left", columns = years_fired) |>
    tab_spanner(label = "Priority Years", columns = c(p1, p2)) |>
    tab_spanner(label = "vs EM-DAT Impact", columns = c(emdat_tp, emdat_fp, emdat_fn, emdat_tn, emdat_f1)) |>
    tab_spanner(label = "vs ERA5 Rainfall", columns = c(era5_tp, era5_fp, era5_fn, era5_tn, era5_tol_f1)) |>
    tab_header(
      title = sprintf("%s: Topline Performance", country_name),
      subtitle = sprintf(
        "%d-year record (%d\u2013%d) | %d EM-DAT impact years",
        eval_end - eval_start + 1, eval_start, eval_end, length(impact_yrs)
      )
    ) |>
    tab_footnote(
      footnote = "P1 = CERF-funded drought years (highest confidence). P2 = all 3 countries in EM-DAT (regional consensus).",
      locations = cells_column_spanners(spanners = "Priority Years")
    ) |>
    tab_footnote(
      footnote = "TP = trigger fires in an impact year. FP = fires in a non-impact year (may still be genuinely dry). FN = misses an impact year.",
      locations = cells_column_spanners(spanners = "vs EM-DAT Impact")
    ) |>
    tab_footnote(
      footnote = "ERA5 tolerant: TP/FP/FN summed across primera + postrera seasons, evaluated against ERA5 observed rainfall drought definition with RP buffer. Independent of impact records.",
      locations = cells_column_spanners(spanners = "vs ERA5 Rainfall")
    ) |>
    opt_css(css = paste0(
      ".yr-p{background:#a0ddd5;color:#333;padding:1px 4px;border-radius:3px;font-size:9px;display:inline-block;margin:1px;}",
      ".yr-b{background:#3aaf9f;color:white;padding:1px 4px;border-radius:3px;font-size:9px;display:inline-block;margin:1px;}",
      ".yr-s{background:#1a6b5a;color:white;padding:1px 4px;border-radius:3px;font-size:9px;display:inline-block;margin:1px;}",
      ".yr-notall{outline:2px solid #e74c3c;outline-offset:-1px;}"
    )) |>
    tab_source_note(
      html(paste0(
        '<span class="yr-p" style="background:#a0ddd5;color:#333;padding:1px 5px;border-radius:3px;font-size:10px;">Primera</span> ',
        '<span class="yr-b" style="background:#3aaf9f;color:white;padding:1px 5px;border-radius:3px;font-size:10px;">Both</span> ',
        '<span class="yr-s" style="background:#1a6b5a;color:white;padding:1px 5px;border-radius:3px;font-size:10px;">Postrera</span> ',
        '<span style="background:#3aaf9f;color:white;padding:1px 5px;border-radius:3px;font-size:10px;outline:2px solid #e74c3c;outline-offset:-1px;">Red outline</span> = not all configs fire'
      ))
    ) |>
    tab_options(
      table.font.size = px(12),
      data_row.padding = px(5),
      column_labels.font.weight = "bold",
      heading.align = "left",
      footnotes.font.size = px(10)
    )
}
```


## Country-Specific Results

::: {.panel-tabset}

### Honduras

```{r}
#| label: hnd-setup

cfg_hnd <- countries$HND
primera_lts_hnd <- 3
postrera_lts_hnd <- 3

impact_yrs_hnd <- impact_by_country$HND$year
target_rp_impact_hnd <- (EVAL_END - EVAL_START + 1 + 1) / length(impact_yrs_hnd)
target_rp_hnd <- 3
```

Honduras uses departments El Paraiso (HN07) and Francisco Morazan (HN08) as the area of interest, with `r primera_lts_hnd` primera leadtimes and `r postrera_lts_hnd` postrera leadtimes. EM-DAT records `r length(impact_yrs_hnd)` impact years in `r EVAL_START`--`r EVAL_END`, giving an empirical impact RP of `r sprintf("%.1f", target_rp_hnd)` years.

**Impact Evaluation & Priority Filtering**

```{r}
#| label: hnd-impact-eval
#| cache: true

combos_hnd <- generate_combos(length(unique(df_hnd$year)),
                               primera_lts = primera_lts_hnd,
                               postrera_lts = postrera_lts_hnd,
                               max_rp = MAX_RP) |>
  grid_constrain_season_monotonic() |>
  grid_constrain_inter_season_monotonic() |>
  grid_constrain_lt_rp_range(min_rp = 4, max_rp = MAX_RP)

trigger_data_hnd <- build_trigger_lookup(df_hnd, min_rp = 2.8, max_rp = MAX_RP,
                                          primera_lts = primera_lts_hnd,
                                          postrera_lts = postrera_lts_hnd)

all_results_hnd <- evaluate_configs_impact(
  combos_hnd, trigger_data_hnd,
  impact_years = impact_yrs_hnd,
  eval_start = EVAL_START, eval_end = EVAL_END
)

all_results_hnd <- all_results_hnd |>
  add_hit_scores(trigger_data_hnd, must_hit_years, should_hit_years,
                 eval_start = EVAL_START, eval_end = EVAL_END) |>
  add_lt_set()

hnd_candidates <- all_results_hnd |>
  filter(p_lt_count == primera_lts_hnd, s_lt_count == postrera_lts_hnd) |>
  filter(must_hit_score == max(must_hit_score)) |>
  filter(should_hit_score == max(should_hit_score))
```

After generating `r format(nrow(combos_hnd), big.mark = ",")` constrained configurations and evaluating against impact years, priority filtering retains **`r format(nrow(hnd_candidates), big.mark = ",")`** candidates that hit `r sprintf("%.0f%%", max(hnd_candidates$must_hit_score) * 100)` of Priority 1 years and `r sprintf("%.0f%%", max(hnd_candidates$should_hit_score) * 100)` of Priority 2 years.


**ERA5 Evaluation & Combined Scoring**

```{r}
#| label: hnd-era5-join
#| cache: true

hnd_candidate_combos <- hnd_candidates |>
  select(any_of(c("p0", "p1", "p2", "s0", "s1", "s2", "s3")))

hnd_era5 <- evaluate_configs(hnd_candidate_combos, trigger_data_hnd, rp_buffer = 1)

threshold_cols_hnd <- intersect(c("p0", "p1", "p2", "s0", "s1", "s2", "s3"),
                                names(hnd_candidates))

hnd_combined <- hnd_candidates |>
  select(config_id, all_of(threshold_cols_hnd),
         impact_f1 = mean_f1,
         impact_primera_f1 = primera_f1,
         impact_postrera_f1 = postrera_f1,
         must_hit_score, should_hit_score,
         annual_rp, p_seasonal_rp, s_seasonal_rp) |>
  left_join(
    hnd_era5 |>
      select(all_of(threshold_cols_hnd),
             era5_matched_f1 = mean_f1,
             era5_tol_f1 = mean_tol_f1,
             era5_primera_tol_f1 = primera_tol_f1,
             era5_postrera_tol_f1 = postrera_tol_f1,
             era5_p_tol_tp = primera_tol_tp, era5_p_tol_fp = primera_tol_fp, era5_p_tol_fn = primera_tol_fn,
             era5_s_tol_tp = postrera_tol_tp, era5_s_tol_fp = postrera_tol_fp, era5_s_tol_fn = postrera_tol_fn,
             mean_cv, all_cv, total_early_tp, total_marginal_fp),
    by = threshold_cols_hnd
  )
```


```{r}
#| label: hnd-tradeoff-data

hnd_tradeoff <- plot_f1_tradeoff(hnd_combined, target_rp = 3, n_nearest = 2)

hnd_all_hl <- hnd_tradeoff$data |> filter(rp_group != "other")

# Option A per RP: best avg_f1, tiebroken by lowest CV
hnd_opt_a <- hnd_tradeoff$best_per_rp |>
  group_by(annual_rp) |>
  arrange(mean_cv) |>
  slice_head(n = 1) |>
  ungroup() |>
  mutate(option = "A", selection = "max avg F1")

# Option B per RP: best era5_tol_f1, tiebroken by lowest CV
hnd_opt_b <- hnd_all_hl |>
  group_by(annual_rp) |>
  filter(era5_tol_f1 == max(era5_tol_f1)) |>
  arrange(mean_cv) |>
  slice_head(n = 1) |>
  ungroup() |>
  mutate(option = "B", selection = "max ERA5 tol F1")

hnd_ab <- bind_rows(hnd_opt_a, hnd_opt_b) |>
  group_by(annual_rp, across(all_of(threshold_cols_hnd))) |>
  mutate(selection = if (n() > 1) "both" else selection) |>
  slice_head(n = 1) |>
  ungroup() |>
  arrange(annual_rp, selection) |>
  group_by(annual_rp) |>
  mutate(option = LETTERS[row_number()]) |>
  ungroup() |>
  mutate(config_label = sprintf("RP %.1f %s", annual_rp, option))

# Uniform configs from PRE-filter pool (bypasses must-hit/should-hit)
message("HND uniform refs:")
hnd_uniform_ref <- get_uniform_refs_prefilter(
  all_results_hnd, threshold_cols_hnd,
  primera_lts_hnd, postrera_lts_hnd,
  target_rp = target_rp_hnd, era5_data = hnd_era5
)

hnd_final <- bind_rows(hnd_ab, hnd_uniform_ref) |>
  mutate(row_idx = row_number())

# Pre-render GT activation tables for each final config
hnd_activation_tables <- lapply(seq_len(nrow(hnd_final)), function(i) {
  tbl <- build_trigger_activation_gt(
    hnd_final[i, ], trigger_data_hnd, df_hnd,
    df_cerf_drought, df_emdat_drought, "HND",
    eval_start = EVAL_START, eval_end = EVAL_END,
    df_emdat_interp = df_emdat_drought_interp,
    must_hit_years = must_hit_years,
    should_hit_years = should_hit_years,
    sort_by = "activation"
  )
  as.character(gt::as_raw_html(tbl))
})

# Default selection: closest to RP 2.9
hnd_default_idx <- which.min(abs(hnd_final$annual_rp - 2.9))
```

The plot below shows each candidate configuration positioned by its ERA5 tolerant F1 (x-axis) and impact F1 (y-axis). Configurations near the top-right corner perform well on both metrics. Circled points mark selected options per RP level: **A** = best average F1, **B** = best ERA5 tolerant F1. **Yellow halos** mark fully uniform configs (all thresholds equal across all leadtimes and seasons) --- an operationally favourable baseline that simplifies trigger communication. Uniform configs are drawn from the pre-filter pool (before must-hit/should-hit filtering) so stricter options that wouldn't pass priority filters are still visible as reference points. Hover over any point for details; click circled or haloed points to view the full per-leadtime activation table.

```{r}
#| label: fig-hnd-tradeoff-static
#| fig-cap: "ERA5 tolerant F1 vs Impact F1 for Honduras candidate configurations. Points colored by annual return period. Circled points indicate the best average F1 at each RP level."
#| eval: false

hnd_tradeoff$plot
```

```{r}
#| label: fig-hnd-tradeoff-interactive
#| fig-cap: "ERA5 tolerant F1 vs Impact F1 for Honduras. Click a circled point to see its trigger activation detail below."

# Build interactive version of the tradeoff plot
hnd_df <- hnd_tradeoff$data
hnd_bg <- hnd_df |> filter(rp_group == "other")
hnd_hl <- hnd_df |> filter(rp_group != "other")

# Reconstruct color palette from rp_group factor levels
rp_levels <- levels(hnd_df$rp_group)
hl_levels <- setdiff(rp_levels, "other")
hl_colors <- c("#e41a1c", "#377eb8", "#4daf4a", "#984ea3",
               "#ff7f00", "#a65628")[seq_along(hl_levels)]
hnd_colors <- c(setNames(hl_colors, hl_levels), "other" = "grey80")

# onclick JS: fully inline, no single quotes (ggiraph restriction)
make_onclick_js <- function(idx, prefix) {
  sprintf(
    paste0(
      'var els=document.getElementsByClassName("%s-activation-tbl");',
      'for(var i=0;i<els.length;i++){els[i].style.display="none";}',
      'document.getElementById("%s-tbl-%d").style.display="block";'
    ),
    prefix, prefix, idx
  )
}

# Deduplicate labels: combine A/B when they share identical coordinates (exclude U)
hnd_labels <- hnd_final |>
  filter(option != "U") |>
  group_by(era5_tol_f1, impact_f1, rp_group) |>
  summarise(
    label = paste(config_label, collapse = " / "),
    avg_f1 = max(avg_f1),
    .groups = "drop"
  ) |>
  mutate(label = sprintf("%s\navg=%.2f", label, avg_f1))

hnd_final_ab <- hnd_final |> filter(option != "U")
hnd_final_u <- hnd_final |> filter(option == "U")

p_hnd <- ggplot(mapping = aes(x = era5_tol_f1, y = impact_f1)) +
  geom_point_interactive(
    data = hnd_bg,
    aes(tooltip = sprintf("RP %.2f | avg F1 = %.3f | CV = %.3f | all CV = %.3f\nImpact = %.3f | ERA5 tol = %.3f",
                          annual_rp, avg_f1, mean_cv, all_cv, impact_f1, era5_tol_f1)),
    color = "grey80", size = 1.5, alpha = 0.4
  ) +
  # Yellow halos behind colored points for uniform configs
  {if (nrow(hnd_final_u) > 0) geom_point_interactive(
    data = hnd_final_u,
    aes(tooltip = sprintf("UNIFORM: RP %.2f | all thresholds = %.1f\navg F1 = %.3f | Impact = %.3f | ERA5 tol = %.3f",
                          annual_rp, .data[[threshold_cols_hnd[1]]], avg_f1, impact_f1, era5_tol_f1),
        data_id = as.character(row_idx),
        onclick = sapply(row_idx, make_onclick_js, prefix = "hnd")),
    color = "#ffd700", size = 9, shape = 1, stroke = 1.5, show.legend = FALSE
  )} +
  geom_point_interactive(
    data = hnd_hl,
    aes(color = rp_group,
        tooltip = sprintf("RP %.2f | avg F1 = %.3f | CV = %.3f | all CV = %.3f\nImpact = %.3f | ERA5 tol = %.3f",
                          annual_rp, avg_f1, mean_cv, all_cv, impact_f1, era5_tol_f1)),
    size = 2.5, alpha = 0.8
  ) +
  geom_point_interactive(
    data = hnd_final_ab,
    aes(color = rp_group,
        tooltip = sprintf("RP %.2f %s (%s)\navg F1 = %.3f | CV = %.3f | all CV = %.3f",
                          annual_rp, option, selection, avg_f1, mean_cv, all_cv),
        data_id = as.character(row_idx),
        onclick = sapply(row_idx, make_onclick_js, prefix = "hnd")),
    size = 5, shape = 21, fill = "transparent", stroke = 1.2, show.legend = FALSE
  ) +
  geom_label_repel(
    data = hnd_labels,
    aes(label = label, color = rp_group),
    size = 2.8, fill = "white", label.size = 0.2,
    show.legend = FALSE, max.overlaps = 30,
    segment.color = "grey50", segment.size = 0.3,
    min.segment.length = 0, force = 5, nudge_x = 0.01
  ) +
  {if (nrow(hnd_final_u) > 0) geom_label_repel(
    data = hnd_final_u,
    aes(label = config_label),
    size = 2.8, fill = alpha("#ffd700", 0.3), label.size = 0.2, color = "black",
    show.legend = FALSE, max.overlaps = 30,
    segment.color = "grey50", segment.size = 0.3,
    min.segment.length = 0, force = 5, nudge_y = 0.02
  )} +
  scale_color_manual(values = hnd_colors, name = "Annual RP") +
  labs(x = "ERA5 Tolerant F1", y = "Impact F1 (EM-DAT)",
       title = "ERA5 vs Impact F1 Tradeoff — Honduras",
       subtitle = "Circles = A (max avg F1) / B (max ERA5) per RP | Yellow halos = uniform (all thresholds equal)") +
  theme_minimal(base_size = 11) +
  theme(legend.position = "right", panel.grid.minor = element_blank())

girafe(ggobj = p_hnd,
       options = list(
         opts_hover(css = "cursor:pointer;stroke-width:3;"),
         opts_selection(type = "single", css = "stroke-width:3;"),
         opts_sizing(rescale = TRUE, width = 1)
       ))
```

```{r}
#| label: tbl-hnd-config-summary

build_config_summary_gt(
  hnd_final, threshold_cols_hnd,
  primera_lts_hnd, postrera_lts_hnd,
  "Honduras",
  top_picks = c("RP 3.2 B", "RP 2.9 B", "RP 2.7 A", "Uniform thresh 5.0)")
)
```

**Trigger Activation Detail (per leadtime)**

Click a circled point on the tradeoff plot above to swap the detailed per-leadtime activation table below.

```{r}
#| label: tbl-hnd-activation-interactive

hnd_divs <- lapply(seq_along(hnd_activation_tables), function(i) {
  display <- if (i == hnd_default_idx) "block" else "none"
  htmltools::div(
    id = sprintf("hnd-tbl-%d", i),
    class = "hnd-activation-tbl",
    style = sprintf("display:%s;", display),
    htmltools::HTML(hnd_activation_tables[[i]])
  )
})
htmltools::browsable(htmltools::tagList(hnd_divs))
```

**Activation Summary**

```{r}
#| label: tbl-hnd-activation-summary

# Helper: compute seasonal activation years for a config
get_seasonal_activation <- function(config_row, trigger_data, eval_start, eval_end) {
  tl <- trigger_data$trigger_lookup
  all_possible <- c("p0", "p1", "p2", "s0", "s1", "s2", "s3")
  active_lts <- character(0)
  for (col in all_possible) {
    if (col %in% names(config_row) && !is.na(config_row[[col]])) {
      active_lts <- c(active_lts, col)
    }
  }
  p_lts <- active_lts[startsWith(active_lts, "p")]
  s_lts <- active_lts[startsWith(active_lts, "s")]

  get_trigger_yrs <- function(lts) {
    yrs <- integer(0)
    for (col in lts) {
      key <- sprintf("%s_%.4f", col, config_row[[col]])
      y <- tl[[key]]
      if (!is.null(y)) yrs <- union(yrs, y)
    }
    yrs[yrs >= eval_start & yrs <= eval_end]
  }
  list(primera = get_trigger_yrs(p_lts), postrera = get_trigger_yrs(s_lts))
}

years <- EVAL_START:EVAL_END

# ERA5 obs RP
obs_by_year_hnd <- df_hnd |>
  filter(year >= EVAL_START, year <= EVAL_END) |>
  distinct(year, window, obs_mm)

hnd_obs_rps <- bind_rows(
  obs_by_year_hnd |> filter(window == "primera") |>
    mutate(obs_rp_pri = (n() + 1) / rank(obs_mm, ties.method = "first")) |>
    select(year, obs_rp_pri),
  obs_by_year_hnd |> filter(window == "postrera") |>
    mutate(obs_rp_post = (n() + 1) / rank(obs_mm, ties.method = "first")) |>
    select(year, obs_rp_post)
) |> group_by(year) |> summarise(across(everything(), ~ max(.x, na.rm = TRUE)), .groups = "drop")

# CERF + EM-DAT interp
cerf_hnd <- df_cerf_drought |>
  filter(iso3 == "HND", year >= EVAL_START, year <= EVAL_END) |>
  distinct(year) |> mutate(cerf = TRUE)

emdat_interp_hnd <- df_emdat_drought_interp |>
  filter(iso3 == "HND", year >= EVAL_START, year <= EVAL_END) |>
  select(year, total_affected_interp)

# Assemble base table
hnd_summary <- tibble(year = years) |>
  mutate(
    priority = case_when(
      year %in% must_hit_years ~ "P1",
      year %in% should_hit_years ~ "P2",
      TRUE ~ ""
    )
  ) |>
  left_join(cerf_hnd, by = "year") |>
  mutate(cerf = replace_na(cerf, FALSE),
         cerf_label = if_else(cerf, "\u2713", "")) |>
  left_join(emdat_interp_hnd, by = "year") |>
  left_join(hnd_obs_rps, by = "year")

# Add activation column per config: "P", "S", "P+S", or ""
for (i in seq_len(nrow(hnd_final))) {
  activation <- get_seasonal_activation(hnd_final[i, ], trigger_data_hnd,
                                         EVAL_START, EVAL_END)
  col_name <- hnd_final$config_label[i]
  p_hit <- hnd_summary$year %in% activation$primera
  s_hit <- hnd_summary$year %in% activation$postrera
  hnd_summary[[col_name]] <- case_when(
    p_hit & s_hit ~ "Pr+Pst",
    p_hit ~ "Pr",
    s_hit ~ "Pst",
    TRUE ~ ""
  )
}

config_labels <- hnd_final$config_label

# Sort: activated years first, then by year
hnd_summary <- hnd_summary |>
  mutate(.any_active = if_any(all_of(config_labels), ~ .x != "")) |>
  arrange(desc(.any_active), year) |>
  select(-.any_active)

hnd_display <- hnd_summary |>
  select(year, priority, cerf_label, total_affected_interp,
         obs_rp_pri, obs_rp_post, all_of(config_labels))

# Compact number label
fmt_compact <- function(v) {
  if_else(is.na(v), "",
    if_else(v >= 1e6, sprintf("%.1fM", v / 1e6),
      if_else(v >= 1e3, sprintf("%.0fK", v / 1e3),
        as.character(as.integer(v)))))
}

# Bar transform for EM-DAT affected
make_bar_transform <- function(color, max_val) {
  function(x) {
    vals <- suppressWarnings(as.numeric(x))
    lapply(vals, function(v) {
      if (is.na(v)) return(gt::html(""))
      pct <- max(v / max_val * 100, 3)
      lbl <- fmt_compact(v)
      txt_col <- if (pct > 25) "white" else "#333"
      gt::html(sprintf(
        paste0(
          '<div style="position:relative;width:100%%;height:16px;">',
          '<div style="background:%s;height:100%%;width:%.0f%%;',
          'border-radius:2px;"></div>',
          '<span style="position:absolute;left:4px;top:0;',
          'font-size:10px;line-height:16px;font-weight:bold;',
          'color:%s;white-space:nowrap;">%s</span></div>'
        ),
        color, pct, txt_col, lbl
      ))
    })
  }
}

hnd_max_bar <- max(hnd_display$total_affected_interp, na.rm = TRUE)

# Build GT
tbl <- hnd_display |>
  gt() |>
  cols_label(
    year = "Year", priority = "P", cerf_label = "CERF",
    total_affected_interp = "EM-DAT",
    obs_rp_pri = "Pri", obs_rp_post = "Post"
  ) |>
  fmt_number(columns = c(obs_rp_pri, obs_rp_post), decimals = 1) |>
  sub_missing(columns = c(obs_rp_pri, obs_rp_post), missing_text = "") |>
  text_transform(
    locations = cells_body(columns = total_affected_interp),
    fn = make_bar_transform("#e6550d", hnd_max_bar)
  ) |>
  tab_spanner(label = "ERA5 Obs RP", columns = c(obs_rp_pri, obs_rp_post)) |>
  tab_spanner(label = "Activation", columns = all_of(config_labels))

# Style: activation cells green when non-empty
for (col in config_labels) {
  active_rows <- which(hnd_display[[col]] != "")
  if (length(active_rows) > 0) {
    tbl <- tbl |>
      tab_style(
        style = list(cell_fill(color = "#d4edda"), cell_text(weight = "bold")),
        locations = cells_body(columns = !!col, rows = active_rows)
      )
  }
}

tbl |>
  tab_style(style = cell_fill(color = "#fde0dd"),
            locations = cells_body(columns = priority, rows = priority == "P1")) |>
  tab_style(style = cell_fill(color = "#fff7bc"),
            locations = cells_body(columns = priority, rows = priority == "P2")) |>
  tab_style(style = cell_fill(color = "#d4edda"),
            locations = cells_body(columns = cerf_label, rows = cerf_label == "\u2713")) |>
  data_color(columns = c(obs_rp_pri, obs_rp_post),
             palette = c("#FDEBD0", "#8B4513"),
             domain = c(1, max(c(hnd_display$obs_rp_pri, hnd_display$obs_rp_post), na.rm = TRUE)),
             na_color = "white") |>
  cols_align(align = "center") |>
  tab_header(
    title = "Honduras: Activation Summary",
    subtitle = "Pr = primera only | Pst = postrera only | Pr+Pst = both seasons"
  ) |>
  tab_options(table.font.size = px(11), data_row.padding = px(2))
```

```{r}
#| label: tbl-hnd-topline

build_topline_gt(
  hnd_final,
  top_picks = c("RP 3.2 B", "RP 2.9 B", "RP 2.7 A", "Uniform thresh 5.0)"),
  trigger_data_hnd, impact_yrs_hnd,
  must_hit_years, should_hit_years,
  EVAL_START, EVAL_END, "Honduras"
) |> as_raw_html()
```

```{r}
#| label: tbl-hnd-final
#| tbl-cap: "Honduras recommended configurations: best average F1 per return period, tiebroken by lowest threshold CV."

hnd_final |>
  select(
    config_label, selection,
    any_of(c("p0", "p1", "p2", "s0", "s1", "s2", "s3")),
    annual_rp, p_seasonal_rp, s_seasonal_rp,
    impact_f1, era5_tol_f1, avg_f1, mean_cv, all_cv
  ) |>
  mutate(
    across(c(impact_f1, era5_tol_f1, avg_f1, mean_cv, all_cv), \(x) round(x, 3)),
    across(c(annual_rp, p_seasonal_rp, s_seasonal_rp), \(x) round(x, 2))
  ) |>
  gt() |>
  cols_align(align = "center") |>
  cols_label(selection = "Criterion") |>
  tab_spanner(label = "Primera thresholds (RP)", columns = starts_with("p")) |>
  tab_spanner(label = "Postrera thresholds (RP)", columns = starts_with("s")) |>
  tab_spanner(label = "Return periods", columns = c(annual_rp, p_seasonal_rp, s_seasonal_rp)) |>
  tab_spanner(label = "Performance", columns = c(impact_f1, era5_tol_f1, avg_f1, mean_cv, all_cv)) |>
  tab_header(
    title = "Honduras: Recommended Configurations",
    subtitle = "A = max avg F1 | B = max ERA5 tol F1 | U = uniform (all thresholds equal)"
  )
```


### El Salvador

```{r}
#| label: slv-setup

cfg_slv <- countries$SLV
primera_lts_slv <- 3
postrera_lts_slv <- 2

impact_yrs_slv <- impact_by_country$SLV$year
target_rp_slv <- 3
```

El Salvador uses country-level (admin 0) aggregation with `r primera_lts_slv` primera leadtimes and `r postrera_lts_slv` postrera leadtimes. EM-DAT records `r length(impact_yrs_slv)` impact years. We use a target RP of `r target_rp_slv`.

**Impact Evaluation & Priority Filtering**

```{r}
#| label: slv-impact-eval
#| cache: true

combos_slv <- generate_combos(length(unique(df_slv$year)),
                               primera_lts = primera_lts_slv,
                               postrera_lts = postrera_lts_slv,
                               max_rp = MAX_RP) |>
  grid_constrain_season_monotonic() |>
  grid_constrain_inter_season_monotonic() |>
  grid_constrain_lt_rp_range(min_rp = 4, max_rp = MAX_RP)

trigger_data_slv <- build_trigger_lookup(df_slv, min_rp = 2.8, max_rp = MAX_RP,
                                          primera_lts = primera_lts_slv,
                                          postrera_lts = postrera_lts_slv)

all_results_slv <- evaluate_configs_impact(
  combos_slv, trigger_data_slv,
  impact_years = impact_yrs_slv,
  eval_start = EVAL_START, eval_end = EVAL_END
)

all_results_slv <- all_results_slv |>
  add_hit_scores(trigger_data_slv, must_hit_years, should_hit_years,
                 eval_start = EVAL_START, eval_end = EVAL_END) |>
  add_lt_set()

slv_candidates <- all_results_slv |>
  filter(p_lt_count == primera_lts_slv, s_lt_count == postrera_lts_slv) |>
  filter(must_hit_score == max(must_hit_score)) |>
  filter(should_hit_score == max(should_hit_score))
```

After priority filtering, **`r format(nrow(slv_candidates), big.mark = ",")`** candidates remain, hitting `r sprintf("%.0f%%", max(slv_candidates$must_hit_score) * 100)` of Priority 1 years and `r sprintf("%.0f%%", max(slv_candidates$should_hit_score) * 100)` of Priority 2 years.


**ERA5 Evaluation & Combined Scoring**

```{r}
#| label: slv-era5-join
#| cache: true

slv_candidate_combos <- slv_candidates |>
  select(any_of(c("p0", "p1", "p2", "s0", "s1", "s2", "s3")))

slv_era5 <- evaluate_configs(slv_candidate_combos, trigger_data_slv, rp_buffer = 1)

threshold_cols_slv <- intersect(c("p0", "p1", "p2", "s0", "s1", "s2", "s3"),
                                names(slv_candidates))

slv_combined <- slv_candidates |>
  select(config_id, all_of(threshold_cols_slv),
         impact_f1 = mean_f1,
         impact_primera_f1 = primera_f1,
         impact_postrera_f1 = postrera_f1,
         must_hit_score, should_hit_score,
         annual_rp, p_seasonal_rp, s_seasonal_rp) |>
  left_join(
    slv_era5 |>
      select(all_of(threshold_cols_slv),
             era5_matched_f1 = mean_f1,
             era5_tol_f1 = mean_tol_f1,
             era5_primera_tol_f1 = primera_tol_f1,
             era5_postrera_tol_f1 = postrera_tol_f1,
             era5_p_tol_tp = primera_tol_tp, era5_p_tol_fp = primera_tol_fp, era5_p_tol_fn = primera_tol_fn,
             era5_s_tol_tp = postrera_tol_tp, era5_s_tol_fp = postrera_tol_fp, era5_s_tol_fn = postrera_tol_fn,
             mean_cv, all_cv, total_early_tp, total_marginal_fp),
    by = threshold_cols_slv
  )
```


```{r}
#| label: slv-tradeoff-data

slv_tradeoff <- plot_f1_tradeoff(slv_combined, target_rp = target_rp_slv, n_nearest = 2)

slv_all_hl <- slv_tradeoff$data |> filter(rp_group != "other")

# Option A per RP: best avg_f1, tiebroken by lowest CV
slv_opt_a <- slv_tradeoff$best_per_rp |>
  group_by(annual_rp) |>
  arrange(mean_cv) |>
  slice_head(n = 1) |>
  ungroup() |>
  mutate(option = "A", selection = "max avg F1")

# Option B per RP: best era5_tol_f1, tiebroken by lowest CV
slv_opt_b <- slv_all_hl |>
  group_by(annual_rp) |>
  filter(era5_tol_f1 == max(era5_tol_f1)) |>
  arrange(mean_cv) |>
  slice_head(n = 1) |>
  ungroup() |>
  mutate(option = "B", selection = "max ERA5 tol F1")

slv_ab <- bind_rows(slv_opt_a, slv_opt_b) |>
  group_by(annual_rp, across(all_of(threshold_cols_slv))) |>
  mutate(selection = if (n() > 1) "both" else selection) |>
  slice_head(n = 1) |>
  ungroup() |>
  arrange(annual_rp, selection) |>
  group_by(annual_rp) |>
  mutate(option = LETTERS[row_number()]) |>
  ungroup() |>
  mutate(config_label = sprintf("RP %.1f %s", annual_rp, option))

# Uniform configs from PRE-filter pool (bypasses must-hit/should-hit)
message("SLV uniform refs:")
slv_uniform_ref <- get_uniform_refs_prefilter(
  all_results_slv, threshold_cols_slv,
  primera_lts_slv, postrera_lts_slv,
  target_rp = target_rp_slv, era5_data = slv_era5
)

slv_final <- bind_rows(slv_ab, slv_uniform_ref) |>
  mutate(row_idx = row_number())

# Pre-render GT activation tables for each final config
slv_activation_tables <- lapply(seq_len(nrow(slv_final)), function(i) {
  tbl <- build_trigger_activation_gt(
    slv_final[i, ], trigger_data_slv, df_slv,
    df_cerf_drought, df_emdat_drought, "SLV",
    eval_start = EVAL_START, eval_end = EVAL_END,
    df_emdat_interp = df_emdat_drought_interp,
    must_hit_years = must_hit_years,
    should_hit_years = should_hit_years,
    sort_by = "activation"
  )
  as.character(gt::as_raw_html(tbl))
})

slv_default_idx <- which.min(abs(slv_final$annual_rp - 2.9))
```

```{r}
#| label: fig-slv-tradeoff-static
#| fig-cap: "ERA5 tolerant F1 vs Impact F1 for El Salvador candidate configurations."
#| eval: false

slv_tradeoff$plot
```

```{r}
#| label: fig-slv-tradeoff-interactive
#| fig-cap: "ERA5 tolerant F1 vs Impact F1 for El Salvador. Click a circled point to see its trigger activation detail below."

slv_df <- slv_tradeoff$data
slv_bg <- slv_df |> filter(rp_group == "other")
slv_hl <- slv_df |> filter(rp_group != "other")

slv_rp_levels <- levels(slv_df$rp_group)
slv_hl_levels <- setdiff(slv_rp_levels, "other")
slv_hl_colors <- c("#e41a1c", "#377eb8", "#4daf4a", "#984ea3",
                    "#ff7f00", "#a65628")[seq_along(slv_hl_levels)]
slv_colors <- c(setNames(slv_hl_colors, slv_hl_levels), "other" = "grey80")

# Deduplicate labels: combine A/B when they share identical coordinates (exclude U)
slv_labels <- slv_final |>
  filter(option != "U") |>
  group_by(era5_tol_f1, impact_f1, rp_group) |>
  summarise(
    label = paste(config_label, collapse = " / "),
    avg_f1 = max(avg_f1),
    .groups = "drop"
  ) |>
  mutate(label = sprintf("%s\navg=%.2f", label, avg_f1))

slv_final_ab <- slv_final |> filter(option != "U")
slv_final_u <- slv_final |> filter(option == "U")
# Flip label below when uniform config shares thresholds with an A/B config
slv_final_u$label_nudge <- sapply(seq_len(nrow(slv_final_u)), function(i) {
  has_overlap <- any(sapply(seq_len(nrow(slv_final_ab)), function(j) {
    all(sapply(threshold_cols_slv, function(col) {
      isTRUE(all.equal(slv_final_u[[col]][i], slv_final_ab[[col]][j]))
    }))
  }))
  if (has_overlap) -0.02 else 0.02
})

p_slv <- ggplot(mapping = aes(x = era5_tol_f1, y = impact_f1)) +
  geom_point_interactive(
    data = slv_bg,
    aes(tooltip = sprintf("RP %.2f | avg F1 = %.3f | CV = %.3f | all CV = %.3f\nImpact = %.3f | ERA5 tol = %.3f",
                          annual_rp, avg_f1, mean_cv, all_cv, impact_f1, era5_tol_f1)),
    color = "grey80", size = 1.5, alpha = 0.4
  ) +
  {if (nrow(slv_final_u) > 0) geom_point_interactive(
    data = slv_final_u,
    aes(tooltip = sprintf("UNIFORM: RP %.2f | all thresholds = %.1f\navg F1 = %.3f | Impact = %.3f | ERA5 tol = %.3f",
                          annual_rp, .data[[threshold_cols_slv[1]]], avg_f1, impact_f1, era5_tol_f1),
        data_id = as.character(row_idx),
        onclick = sapply(row_idx, make_onclick_js, prefix = "slv")),
    color = "#ffd700", size = 9, shape = 1, stroke = 1.5, show.legend = FALSE
  )} +
  geom_point_interactive(
    data = slv_hl,
    aes(color = rp_group,
        tooltip = sprintf("RP %.2f | avg F1 = %.3f | CV = %.3f | all CV = %.3f\nImpact = %.3f | ERA5 tol = %.3f",
                          annual_rp, avg_f1, mean_cv, all_cv, impact_f1, era5_tol_f1)),
    size = 2.5, alpha = 0.8
  ) +
  geom_point_interactive(
    data = slv_final_ab,
    aes(color = rp_group,
        tooltip = sprintf("RP %.2f %s (%s)\navg F1 = %.3f | CV = %.3f | all CV = %.3f",
                          annual_rp, option, selection, avg_f1, mean_cv, all_cv),
        data_id = as.character(row_idx),
        onclick = sapply(row_idx, make_onclick_js, prefix = "slv")),
    size = 5, shape = 21, fill = "transparent", stroke = 1.2, show.legend = FALSE
  ) +
  geom_label_repel(
    data = slv_labels,
    aes(label = label, color = rp_group),
    size = 2.8, fill = "white", label.size = 0.2,
    show.legend = FALSE, max.overlaps = 30,
    segment.color = "grey50", segment.size = 0.3,
    min.segment.length = 0, force = 5, nudge_x = 0.01
  ) +
  {if (nrow(slv_final_u) > 0) geom_label_repel(
    data = slv_final_u,
    aes(label = config_label),
    size = 2.8, fill = alpha("#ffd700", 0.3), label.size = 0.2, color = "black",
    show.legend = FALSE, max.overlaps = 30,
    segment.color = "grey50", segment.size = 0.3,
    min.segment.length = 0, force = 5, nudge_y = slv_final_u$label_nudge
  )} +
  scale_color_manual(values = slv_colors, name = "Annual RP") +
  labs(x = "ERA5 Tolerant F1", y = "Impact F1 (EM-DAT)",
       title = "ERA5 vs Impact F1 Tradeoff — El Salvador",
       subtitle = "Circles = A (max avg F1) / B (max ERA5) per RP | Yellow halos = uniform (all thresholds equal)") +
  theme_minimal(base_size = 11) +
  theme(legend.position = "right", panel.grid.minor = element_blank())

girafe(ggobj = p_slv,
       options = list(
         opts_hover(css = "cursor:pointer;stroke-width:3;"),
         opts_selection(type = "single", css = "stroke-width:3;"),
         opts_sizing(rescale = TRUE, width = 1)
       ))
```

```{r}
#| label: tbl-slv-config-summary

build_config_summary_gt(
  slv_final, threshold_cols_slv,
  primera_lts_slv, postrera_lts_slv,
  "El Salvador",
  top_picks = c("RP 2.9 A")
)
```

**Trigger Activation Detail (per leadtime)**

Click a circled point on the tradeoff plot above to swap the detailed per-leadtime activation table below.

```{r}
#| label: tbl-slv-activation-interactive

slv_divs <- lapply(seq_along(slv_activation_tables), function(i) {
  display <- if (i == slv_default_idx) "block" else "none"
  htmltools::div(
    id = sprintf("slv-tbl-%d", i),
    class = "slv-activation-tbl",
    style = sprintf("display:%s;", display),
    htmltools::HTML(slv_activation_tables[[i]])
  )
})
htmltools::browsable(htmltools::tagList(slv_divs))
```

**Activation Summary**

```{r}
#| label: tbl-slv-activation-summary

obs_by_year_slv <- df_slv |>
  filter(year >= EVAL_START, year <= EVAL_END) |>
  distinct(year, window, obs_mm)

slv_obs_rps <- bind_rows(
  obs_by_year_slv |> filter(window == "primera") |>
    mutate(obs_rp_pri = (n() + 1) / rank(obs_mm, ties.method = "first")) |>
    select(year, obs_rp_pri),
  obs_by_year_slv |> filter(window == "postrera") |>
    mutate(obs_rp_post = (n() + 1) / rank(obs_mm, ties.method = "first")) |>
    select(year, obs_rp_post)
) |> group_by(year) |> summarise(across(everything(), ~ max(.x, na.rm = TRUE)), .groups = "drop")

cerf_slv <- df_cerf_drought |>
  filter(iso3 == "SLV", year >= EVAL_START, year <= EVAL_END) |>
  distinct(year) |> mutate(cerf = TRUE)

emdat_interp_slv <- df_emdat_drought_interp |>
  filter(iso3 == "SLV", year >= EVAL_START, year <= EVAL_END) |>
  select(year, total_affected_interp)

slv_summary <- tibble(year = years) |>
  mutate(
    priority = case_when(
      year %in% must_hit_years ~ "P1",
      year %in% should_hit_years ~ "P2",
      TRUE ~ ""
    )
  ) |>
  left_join(cerf_slv, by = "year") |>
  mutate(cerf = replace_na(cerf, FALSE),
         cerf_label = if_else(cerf, "\u2713", "")) |>
  left_join(emdat_interp_slv, by = "year") |>
  left_join(slv_obs_rps, by = "year")

for (i in seq_len(nrow(slv_final))) {
  activation <- get_seasonal_activation(slv_final[i, ], trigger_data_slv,
                                         EVAL_START, EVAL_END)
  col_name <- slv_final$config_label[i]
  p_hit <- slv_summary$year %in% activation$primera
  s_hit <- slv_summary$year %in% activation$postrera
  slv_summary[[col_name]] <- case_when(
    p_hit & s_hit ~ "Pr+Pst",
    p_hit ~ "Pr",
    s_hit ~ "Pst",
    TRUE ~ ""
  )
}

slv_config_labels <- slv_final$config_label

slv_summary <- slv_summary |>
  mutate(.any_active = if_any(all_of(slv_config_labels), ~ .x != "")) |>
  arrange(desc(.any_active), year) |>
  select(-.any_active)

slv_display <- slv_summary |>
  select(year, priority, cerf_label, total_affected_interp,
         obs_rp_pri, obs_rp_post, all_of(slv_config_labels))

slv_max_bar <- max(slv_display$total_affected_interp, na.rm = TRUE)

tbl_slv <- slv_display |>
  gt() |>
  cols_label(
    year = "Year", priority = "P", cerf_label = "CERF",
    total_affected_interp = "EM-DAT",
    obs_rp_pri = "Pri", obs_rp_post = "Post"
  ) |>
  fmt_number(columns = c(obs_rp_pri, obs_rp_post), decimals = 1) |>
  sub_missing(columns = c(obs_rp_pri, obs_rp_post), missing_text = "") |>
  text_transform(
    locations = cells_body(columns = total_affected_interp),
    fn = make_bar_transform("#e6550d", slv_max_bar)
  ) |>
  tab_spanner(label = "ERA5 Obs RP", columns = c(obs_rp_pri, obs_rp_post)) |>
  tab_spanner(label = "Activation", columns = all_of(slv_config_labels))

for (col in slv_config_labels) {
  active_rows <- which(slv_display[[col]] != "")
  if (length(active_rows) > 0) {
    tbl_slv <- tbl_slv |>
      tab_style(
        style = list(cell_fill(color = "#d4edda"), cell_text(weight = "bold")),
        locations = cells_body(columns = !!col, rows = active_rows)
      )
  }
}

tbl_slv |>
  tab_style(style = cell_fill(color = "#fde0dd"),
            locations = cells_body(columns = priority, rows = priority == "P1")) |>
  tab_style(style = cell_fill(color = "#fff7bc"),
            locations = cells_body(columns = priority, rows = priority == "P2")) |>
  tab_style(style = cell_fill(color = "#d4edda"),
            locations = cells_body(columns = cerf_label, rows = cerf_label == "\u2713")) |>
  data_color(columns = c(obs_rp_pri, obs_rp_post),
             palette = c("#FDEBD0", "#8B4513"),
             domain = c(1, max(c(slv_display$obs_rp_pri, slv_display$obs_rp_post), na.rm = TRUE)),
             na_color = "white") |>
  cols_align(align = "center") |>
  tab_header(
    title = "El Salvador: Activation Summary",
    subtitle = "Pr = primera only | Pst = postrera only | Pr+Pst = both seasons"
  ) |>
  tab_options(table.font.size = px(11), data_row.padding = px(2))
```

```{r}
#| label: tbl-slv-final
#| tbl-cap: "El Salvador recommended configurations: best average F1 per return period, tiebroken by lowest threshold CV."

slv_final |>
  select(
    config_label, selection,
    any_of(c("p0", "p1", "p2", "s0", "s1")),
    annual_rp, p_seasonal_rp, s_seasonal_rp,
    impact_f1, era5_tol_f1, avg_f1, mean_cv, all_cv
  ) |>
  mutate(
    across(c(impact_f1, era5_tol_f1, avg_f1, mean_cv, all_cv), \(x) round(x, 3)),
    across(c(annual_rp, p_seasonal_rp, s_seasonal_rp), \(x) round(x, 2))
  ) |>
  gt() |>
  cols_align(align = "center") |>
  cols_label(selection = "Criterion") |>
  tab_spanner(label = "Primera thresholds (RP)", columns = starts_with("p")) |>
  tab_spanner(label = "Postrera thresholds (RP)", columns = starts_with("s")) |>
  tab_spanner(label = "Return periods", columns = c(annual_rp, p_seasonal_rp, s_seasonal_rp)) |>
  tab_spanner(label = "Performance", columns = c(impact_f1, era5_tol_f1, avg_f1, mean_cv, all_cv)) |>
  tab_header(
    title = "El Salvador: Recommended Configurations",
    subtitle = "A = max avg F1 | B = max ERA5 tol F1 | U = uniform (all thresholds equal)"
  )
```

```{r}
#| label: tbl-slv-topline

build_topline_gt(
  slv_final,
  top_picks = c("RP 2.9 A"),
  trigger_data_slv, impact_yrs_slv,
  must_hit_years, should_hit_years,
  EVAL_START, EVAL_END, "El Salvador"
) |> as_raw_html()
```


### Guatemala

```{r}
#| label: gtm-setup

cfg_gtm <- countries$GTM
primera_lts_gtm <- 3
postrera_lts_gtm <- 2

impact_yrs_gtm <- impact_by_country$GTM$year
target_rp_impact_gtm <- (EVAL_END - EVAL_START + 1 + 1) / length(impact_yrs_gtm)
target_rp_gtm <- 3
```

Guatemala uses departments Chiquimula (GT20) and Alta Verapaz (GT16) as the area of interest, with `r primera_lts_gtm` primera leadtimes and `r postrera_lts_gtm` postrera leadtimes. EM-DAT records `r length(impact_yrs_gtm)` impact years in `r EVAL_START`--`r EVAL_END`, giving an empirical impact RP of `r sprintf("%.1f", target_rp_gtm)` years.

**Impact Evaluation & Priority Filtering**

```{r}
#| label: gtm-impact-eval
#| cache: true

combos_gtm <- generate_combos(length(unique(df_gtm$year)),
                               primera_lts = primera_lts_gtm,
                               postrera_lts = postrera_lts_gtm,
                               max_rp = MAX_RP) |>
  grid_constrain_season_monotonic() |>
  grid_constrain_inter_season_monotonic() |>
  grid_constrain_lt_rp_range(min_rp = 4, max_rp = MAX_RP)

trigger_data_gtm <- build_trigger_lookup(df_gtm, min_rp = 2.8, max_rp = MAX_RP,
                                          primera_lts = primera_lts_gtm,
                                          postrera_lts = postrera_lts_gtm)

all_results_gtm <- evaluate_configs_impact(
  combos_gtm, trigger_data_gtm,
  impact_years = impact_yrs_gtm,
  eval_start = EVAL_START, eval_end = EVAL_END
)

all_results_gtm <- all_results_gtm |>
  add_hit_scores(trigger_data_gtm, must_hit_years, should_hit_years,
                 eval_start = EVAL_START, eval_end = EVAL_END) |>
  add_lt_set()

gtm_candidates <- all_results_gtm |>
  filter(p_lt_count == primera_lts_gtm, s_lt_count == postrera_lts_gtm) |>
  filter(must_hit_score == max(must_hit_score)) |>
  filter(should_hit_score == max(should_hit_score))
```

After generating `r format(nrow(combos_gtm), big.mark = ",")` constrained configurations and evaluating against impact years, priority filtering retains **`r format(nrow(gtm_candidates), big.mark = ",")`** candidates that hit `r sprintf("%.0f%%", max(gtm_candidates$must_hit_score) * 100)` of Priority 1 years and `r sprintf("%.0f%%", max(gtm_candidates$should_hit_score) * 100)` of Priority 2 years.


**ERA5 Evaluation & Combined Scoring**

```{r}
#| label: gtm-era5-join
#| cache: true

gtm_candidate_combos <- gtm_candidates |>
  select(any_of(c("p0", "p1", "p2", "s0", "s1", "s2", "s3")))

gtm_era5 <- evaluate_configs(gtm_candidate_combos, trigger_data_gtm, rp_buffer = 1)

threshold_cols_gtm <- intersect(c("p0", "p1", "p2", "s0", "s1", "s2", "s3"),
                                names(gtm_candidates))

gtm_combined <- gtm_candidates |>
  select(config_id, all_of(threshold_cols_gtm),
         impact_f1 = mean_f1,
         impact_primera_f1 = primera_f1,
         impact_postrera_f1 = postrera_f1,
         must_hit_score, should_hit_score,
         annual_rp, p_seasonal_rp, s_seasonal_rp) |>
  left_join(
    gtm_era5 |>
      select(all_of(threshold_cols_gtm),
             era5_matched_f1 = mean_f1,
             era5_tol_f1 = mean_tol_f1,
             era5_primera_tol_f1 = primera_tol_f1,
             era5_postrera_tol_f1 = postrera_tol_f1,
             era5_p_tol_tp = primera_tol_tp, era5_p_tol_fp = primera_tol_fp, era5_p_tol_fn = primera_tol_fn,
             era5_s_tol_tp = postrera_tol_tp, era5_s_tol_fp = postrera_tol_fp, era5_s_tol_fn = postrera_tol_fn,
             mean_cv, all_cv, total_early_tp, total_marginal_fp),
    by = threshold_cols_gtm
  )
```


```{r}
#| label: gtm-tradeoff-data

gtm_tradeoff <- plot_f1_tradeoff(gtm_combined, target_rp = target_rp_gtm, n_nearest = 2)

gtm_all_hl <- gtm_tradeoff$data |> filter(rp_group != "other")

# Option A per RP: best avg_f1, tiebroken by lowest CV
gtm_opt_a <- gtm_tradeoff$best_per_rp |>
  group_by(annual_rp) |>
  arrange(mean_cv) |>
  slice_head(n = 1) |>
  ungroup() |>
  mutate(option = "A", selection = "max avg F1")

# Option B per RP: best era5_tol_f1, tiebroken by lowest CV
gtm_opt_b <- gtm_all_hl |>
  group_by(annual_rp) |>
  filter(era5_tol_f1 == max(era5_tol_f1)) |>
  arrange(mean_cv) |>
  slice_head(n = 1) |>
  ungroup() |>
  mutate(option = "B", selection = "max ERA5 tol F1")

gtm_ab <- bind_rows(gtm_opt_a, gtm_opt_b) |>
  group_by(annual_rp, across(all_of(threshold_cols_gtm))) |>
  mutate(selection = if (n() > 1) "both" else selection) |>
  slice_head(n = 1) |>
  ungroup() |>
  arrange(annual_rp, selection) |>
  group_by(annual_rp) |>
  mutate(option = LETTERS[row_number()]) |>
  ungroup() |>
  mutate(config_label = sprintf("RP %.1f %s", annual_rp, option))

# Uniform configs from PRE-filter pool (bypasses must-hit/should-hit)
message("GTM uniform refs:")
gtm_uniform_ref <- get_uniform_refs_prefilter(
  all_results_gtm, threshold_cols_gtm,
  primera_lts_gtm, postrera_lts_gtm,
  target_rp = target_rp_gtm, era5_data = gtm_era5
)

gtm_final <- bind_rows(gtm_ab, gtm_uniform_ref) |>
  mutate(row_idx = row_number())

# Pre-render GT activation tables for each final config
gtm_activation_tables <- lapply(seq_len(nrow(gtm_final)), function(i) {
  tbl <- build_trigger_activation_gt(
    gtm_final[i, ], trigger_data_gtm, df_gtm,
    df_cerf_drought, df_emdat_drought, "GTM",
    eval_start = EVAL_START, eval_end = EVAL_END,
    df_emdat_interp = df_emdat_drought_interp,
    must_hit_years = must_hit_years,
    should_hit_years = should_hit_years,
    sort_by = "activation"
  )
  as.character(gt::as_raw_html(tbl))
})

gtm_default_idx <- which.min(abs(gtm_final$annual_rp - target_rp_gtm))
```

```{r}
#| label: fig-gtm-tradeoff-interactive
#| fig-cap: "ERA5 tolerant F1 vs Impact F1 for Guatemala. Click a circled point to see its trigger activation detail below."

gtm_df <- gtm_tradeoff$data
gtm_bg <- gtm_df |> filter(rp_group == "other")
gtm_hl <- gtm_df |> filter(rp_group != "other")

gtm_rp_levels <- levels(gtm_df$rp_group)
gtm_hl_levels <- setdiff(gtm_rp_levels, "other")
gtm_hl_colors <- c("#e41a1c", "#377eb8", "#4daf4a", "#984ea3",
                    "#ff7f00", "#a65628")[seq_along(gtm_hl_levels)]
gtm_colors <- c(setNames(gtm_hl_colors, gtm_hl_levels), "other" = "grey80")

# Deduplicate labels (exclude U — uniform gets its own label layer)
gtm_labels <- gtm_final |>
  filter(option != "U") |>
  group_by(era5_tol_f1, impact_f1, rp_group) |>
  summarise(
    label = paste(config_label, collapse = " / "),
    avg_f1 = max(avg_f1),
    .groups = "drop"
  ) |>
  mutate(label = sprintf("%s\navg=%.2f", label, avg_f1))

gtm_final_ab <- gtm_final |> filter(option != "U")
gtm_final_u <- gtm_final |> filter(option == "U")

p_gtm <- ggplot(mapping = aes(x = era5_tol_f1, y = impact_f1)) +
  geom_point_interactive(
    data = gtm_bg,
    aes(tooltip = sprintf("RP %.2f | avg F1 = %.3f | CV = %.3f | all CV = %.3f\nImpact = %.3f | ERA5 tol = %.3f",
                          annual_rp, avg_f1, mean_cv, all_cv, impact_f1, era5_tol_f1)),
    color = "grey80", size = 1.5, alpha = 0.4
  ) +
  {if (nrow(gtm_final_u) > 0) geom_point_interactive(
    data = gtm_final_u,
    aes(tooltip = sprintf("UNIFORM: RP %.2f | all thresholds = %.1f\navg F1 = %.3f | Impact = %.3f | ERA5 tol = %.3f",
                          annual_rp, .data[[threshold_cols_gtm[1]]], avg_f1, impact_f1, era5_tol_f1),
        data_id = as.character(row_idx),
        onclick = sapply(row_idx, make_onclick_js, prefix = "gtm")),
    color = "#ffd700", size = 9, shape = 1, stroke = 1.5, show.legend = FALSE
  )} +
  geom_point_interactive(
    data = gtm_hl,
    aes(color = rp_group,
        tooltip = sprintf("RP %.2f | avg F1 = %.3f | CV = %.3f | all CV = %.3f\nImpact = %.3f | ERA5 tol = %.3f",
                          annual_rp, avg_f1, mean_cv, all_cv, impact_f1, era5_tol_f1)),
    size = 2.5, alpha = 0.8
  ) +
  geom_point_interactive(
    data = gtm_final_ab,
    aes(color = rp_group,
        tooltip = sprintf("RP %.2f %s (%s)\navg F1 = %.3f | CV = %.3f | all CV = %.3f",
                          annual_rp, option, selection, avg_f1, mean_cv, all_cv),
        data_id = as.character(row_idx),
        onclick = sapply(row_idx, make_onclick_js, prefix = "gtm")),
    size = 5, shape = 21, fill = "transparent", stroke = 1.2, show.legend = FALSE
  ) +
  geom_label_repel(
    data = gtm_labels,
    aes(label = label, color = rp_group),
    size = 2.8, fill = "white", label.size = 0.2,
    show.legend = FALSE, max.overlaps = 30,
    segment.color = "grey50", segment.size = 0.3,
    min.segment.length = 0, force = 5, nudge_x = 0.01
  ) +
  {if (nrow(gtm_final_u) > 0) geom_label_repel(
    data = gtm_final_u,
    aes(label = config_label),
    size = 2.8, fill = alpha("#ffd700", 0.3), label.size = 0.2, color = "black",
    show.legend = FALSE, max.overlaps = 30,
    segment.color = "grey50", segment.size = 0.3,
    min.segment.length = 0, force = 5, nudge_y = 0.02
  )} +
  scale_color_manual(values = gtm_colors, name = "Annual RP") +
  labs(x = "ERA5 Tolerant F1", y = "Impact F1 (EM-DAT)",
       title = "ERA5 vs Impact F1 Tradeoff — Guatemala",
       subtitle = "Circles = A (max avg F1) / B (max ERA5) per RP | Yellow halos = uniform (all thresholds equal)") +
  theme_minimal(base_size = 11) +
  theme(legend.position = "right", panel.grid.minor = element_blank())

girafe(ggobj = p_gtm,
       options = list(
         opts_hover(css = "cursor:pointer;stroke-width:3;"),
         opts_selection(type = "single", css = "stroke-width:3;"),
         opts_sizing(rescale = TRUE, width = 1)
       ))
```

```{r}
#| label: tbl-gtm-config-summary

build_config_summary_gt(
  gtm_final, threshold_cols_gtm,
  primera_lts_gtm, postrera_lts_gtm,
  "Guatemala"
)
```

**Trigger Activation Detail (per leadtime)**

Click a circled point on the tradeoff plot above to swap the detailed per-leadtime activation table below.

```{r}
#| label: tbl-gtm-activation-interactive

gtm_divs <- lapply(seq_along(gtm_activation_tables), function(i) {
  display <- if (i == gtm_default_idx) "block" else "none"
  htmltools::div(
    id = sprintf("gtm-tbl-%d", i),
    class = "gtm-activation-tbl",
    style = sprintf("display:%s;", display),
    htmltools::HTML(gtm_activation_tables[[i]])
  )
})
htmltools::browsable(htmltools::tagList(gtm_divs))
```

**Activation Summary**

```{r}
#| label: tbl-gtm-activation-summary

obs_by_year_gtm <- df_gtm |>
  filter(year >= EVAL_START, year <= EVAL_END) |>
  distinct(year, window, obs_mm)

gtm_obs_rps <- bind_rows(
  obs_by_year_gtm |> filter(window == "primera") |>
    mutate(obs_rp_pri = (n() + 1) / rank(obs_mm, ties.method = "first")) |>
    select(year, obs_rp_pri),
  obs_by_year_gtm |> filter(window == "postrera") |>
    mutate(obs_rp_post = (n() + 1) / rank(obs_mm, ties.method = "first")) |>
    select(year, obs_rp_post)
) |> group_by(year) |> summarise(across(everything(), ~ max(.x, na.rm = TRUE)), .groups = "drop")

cerf_gtm <- df_cerf_drought |>
  filter(iso3 == "GTM", year >= EVAL_START, year <= EVAL_END) |>
  distinct(year) |> mutate(cerf = TRUE)

emdat_interp_gtm <- df_emdat_drought_interp |>
  filter(iso3 == "GTM", year >= EVAL_START, year <= EVAL_END) |>
  select(year, total_affected_interp)

gtm_summary <- tibble(year = years) |>
  mutate(
    priority = case_when(
      year %in% must_hit_years ~ "P1",
      year %in% should_hit_years ~ "P2",
      TRUE ~ ""
    )
  ) |>
  left_join(cerf_gtm, by = "year") |>
  mutate(cerf = replace_na(cerf, FALSE),
         cerf_label = if_else(cerf, "\u2713", "")) |>
  left_join(emdat_interp_gtm, by = "year") |>
  left_join(gtm_obs_rps, by = "year")

for (i in seq_len(nrow(gtm_final))) {
  activation <- get_seasonal_activation(gtm_final[i, ], trigger_data_gtm,
                                         EVAL_START, EVAL_END)
  col_name <- gtm_final$config_label[i]
  p_hit <- gtm_summary$year %in% activation$primera
  s_hit <- gtm_summary$year %in% activation$postrera
  gtm_summary[[col_name]] <- case_when(
    p_hit & s_hit ~ "Pr+Pst",
    p_hit ~ "Pr",
    s_hit ~ "Pst",
    TRUE ~ ""
  )
}

gtm_config_labels <- gtm_final$config_label

gtm_summary <- gtm_summary |>
  mutate(.any_active = if_any(all_of(gtm_config_labels), ~ .x != "")) |>
  arrange(desc(.any_active), year) |>
  select(-.any_active)

gtm_display <- gtm_summary |>
  select(year, priority, cerf_label, total_affected_interp,
         obs_rp_pri, obs_rp_post, all_of(gtm_config_labels))

gtm_max_bar <- max(gtm_display$total_affected_interp, na.rm = TRUE)

tbl_gtm <- gtm_display |>
  gt() |>
  cols_label(
    year = "Year", priority = "P", cerf_label = "CERF",
    total_affected_interp = "EM-DAT",
    obs_rp_pri = "Pri", obs_rp_post = "Post"
  ) |>
  fmt_number(columns = c(obs_rp_pri, obs_rp_post), decimals = 1) |>
  sub_missing(columns = c(obs_rp_pri, obs_rp_post), missing_text = "") |>
  text_transform(
    locations = cells_body(columns = total_affected_interp),
    fn = make_bar_transform("#e6550d", gtm_max_bar)
  ) |>
  tab_spanner(label = "ERA5 Obs RP", columns = c(obs_rp_pri, obs_rp_post)) |>
  tab_spanner(label = "Activation", columns = all_of(gtm_config_labels))

for (col in gtm_config_labels) {
  active_rows <- which(gtm_display[[col]] != "")
  if (length(active_rows) > 0) {
    tbl_gtm <- tbl_gtm |>
      tab_style(
        style = list(cell_fill(color = "#d4edda"), cell_text(weight = "bold")),
        locations = cells_body(columns = !!col, rows = active_rows)
      )
  }
}

tbl_gtm |>
  tab_style(style = cell_fill(color = "#fde0dd"),
            locations = cells_body(columns = priority, rows = priority == "P1")) |>
  tab_style(style = cell_fill(color = "#fff7bc"),
            locations = cells_body(columns = priority, rows = priority == "P2")) |>
  tab_style(style = cell_fill(color = "#d4edda"),
            locations = cells_body(columns = cerf_label, rows = cerf_label == "\u2713")) |>
  data_color(columns = c(obs_rp_pri, obs_rp_post),
             palette = c("#FDEBD0", "#8B4513"),
             domain = c(1, max(c(gtm_display$obs_rp_pri, gtm_display$obs_rp_post), na.rm = TRUE)),
             na_color = "white") |>
  cols_align(align = "center") |>
  tab_header(
    title = "Guatemala: Activation Summary",
    subtitle = "Pr = primera only | Pst = postrera only | Pr+Pst = both seasons"
  ) |>
  tab_options(table.font.size = px(11), data_row.padding = px(2))
```

```{r}
#| label: tbl-gtm-final
#| tbl-cap: "Guatemala recommended configurations: best average F1 per return period, tiebroken by lowest threshold CV."

gtm_final |>
  select(
    config_label, selection,
    any_of(c("p0", "p1", "p2", "s0", "s1")),
    annual_rp, p_seasonal_rp, s_seasonal_rp,
    impact_f1, era5_tol_f1, avg_f1, mean_cv, all_cv
  ) |>
  mutate(
    across(c(impact_f1, era5_tol_f1, avg_f1, mean_cv, all_cv), \(x) round(x, 3)),
    across(c(annual_rp, p_seasonal_rp, s_seasonal_rp), \(x) round(x, 2))
  ) |>
  gt() |>
  cols_align(align = "center") |>
  cols_label(selection = "Criterion") |>
  tab_spanner(label = "Primera thresholds (RP)", columns = starts_with("p")) |>
  tab_spanner(label = "Postrera thresholds (RP)", columns = starts_with("s")) |>
  tab_spanner(label = "Return periods", columns = c(annual_rp, p_seasonal_rp, s_seasonal_rp)) |>
  tab_spanner(label = "Performance", columns = c(impact_f1, era5_tol_f1, avg_f1, mean_cv, all_cv)) |>
  tab_header(
    title = "Guatemala: Recommended Configurations",
    subtitle = "A = max avg F1 | B = max ERA5 tol F1 | U = uniform (all thresholds equal)"
  )
```


### Guatemala (StartNetwork)

```{r}
#| label: gtmsn-setup

cfg_gtmsn <- countries$GTM_SN
primera_lts_gtmsn <- 3
postrera_lts_gtmsn <- 2

impact_yrs_gtmsn <- impact_by_country$GTM$year
target_rp_impact_gtmsn <- (EVAL_END - EVAL_START + 1 + 1) / length(impact_yrs_gtmsn)
target_rp_gtmsn <- 3
```

The StartNetwork Guatemala AOI uses departments Quiché (GT14) and Baja Verapaz (GT15), with `r primera_lts_gtmsn` primera leadtimes and `r postrera_lts_gtmsn` postrera leadtimes. Impact years are drawn from the same country-level EM-DAT record (`r length(impact_yrs_gtmsn)` events, empirical RP = `r sprintf("%.1f", target_rp_gtmsn)`).

**Impact Evaluation & Priority Filtering**

```{r}
#| label: gtmsn-impact-eval
#| cache: true

combos_gtmsn <- generate_combos(length(unique(df_gtm_sn$year)),
                                 primera_lts = primera_lts_gtmsn,
                                 postrera_lts = postrera_lts_gtmsn,
                                 max_rp = MAX_RP) |>
  grid_constrain_season_monotonic() |>
  grid_constrain_inter_season_monotonic() |>
  grid_constrain_lt_rp_range(min_rp = 4, max_rp = MAX_RP)

trigger_data_gtmsn <- build_trigger_lookup(df_gtm_sn, min_rp = 2.8, max_rp = MAX_RP,
                                            primera_lts = primera_lts_gtmsn,
                                            postrera_lts = postrera_lts_gtmsn)

all_results_gtmsn <- evaluate_configs_impact(
  combos_gtmsn, trigger_data_gtmsn,
  impact_years = impact_yrs_gtmsn,
  eval_start = EVAL_START, eval_end = EVAL_END
)

all_results_gtmsn <- all_results_gtmsn |>
  add_hit_scores(trigger_data_gtmsn, must_hit_years, should_hit_years,
                 eval_start = EVAL_START, eval_end = EVAL_END) |>
  add_lt_set()

gtmsn_candidates <- all_results_gtmsn |>
  filter(p_lt_count == primera_lts_gtmsn, s_lt_count == postrera_lts_gtmsn) |>
  filter(must_hit_score == max(must_hit_score)) |>
  filter(should_hit_score == max(should_hit_score))
```

After priority filtering, **`r format(nrow(gtmsn_candidates), big.mark = ",")`** candidates remain, hitting `r sprintf("%.0f%%", max(gtmsn_candidates$must_hit_score) * 100)` of Priority 1 years and `r sprintf("%.0f%%", max(gtmsn_candidates$should_hit_score) * 100)` of Priority 2 years.


**ERA5 Evaluation & Combined Scoring**

```{r}
#| label: gtmsn-era5-join
#| cache: true

gtmsn_candidate_combos <- gtmsn_candidates |>
  select(any_of(c("p0", "p1", "p2", "s0", "s1", "s2", "s3")))

gtmsn_era5 <- evaluate_configs(gtmsn_candidate_combos, trigger_data_gtmsn, rp_buffer = 1)

threshold_cols_gtmsn <- intersect(c("p0", "p1", "p2", "s0", "s1", "s2", "s3"),
                                  names(gtmsn_candidates))

gtmsn_combined <- gtmsn_candidates |>
  select(config_id, all_of(threshold_cols_gtmsn),
         impact_f1 = mean_f1,
         impact_primera_f1 = primera_f1,
         impact_postrera_f1 = postrera_f1,
         must_hit_score, should_hit_score,
         annual_rp, p_seasonal_rp, s_seasonal_rp) |>
  left_join(
    gtmsn_era5 |>
      select(all_of(threshold_cols_gtmsn),
             era5_matched_f1 = mean_f1,
             era5_tol_f1 = mean_tol_f1,
             era5_primera_tol_f1 = primera_tol_f1,
             era5_postrera_tol_f1 = postrera_tol_f1,
             era5_p_tol_tp = primera_tol_tp, era5_p_tol_fp = primera_tol_fp, era5_p_tol_fn = primera_tol_fn,
             era5_s_tol_tp = postrera_tol_tp, era5_s_tol_fp = postrera_tol_fp, era5_s_tol_fn = postrera_tol_fn,
             mean_cv, all_cv, total_early_tp, total_marginal_fp),
    by = threshold_cols_gtmsn
  )
```


```{r}
#| label: gtmsn-tradeoff-data

gtmsn_tradeoff <- plot_f1_tradeoff(gtmsn_combined, target_rp = target_rp_gtmsn, n_nearest = 2)

gtmsn_all_hl <- gtmsn_tradeoff$data |> filter(rp_group != "other")

# Option A per RP: best avg_f1, tiebroken by lowest CV
gtmsn_opt_a <- gtmsn_tradeoff$best_per_rp |>
  group_by(annual_rp) |>
  arrange(mean_cv) |>
  slice_head(n = 1) |>
  ungroup() |>
  mutate(option = "A", selection = "max avg F1")

# Option B per RP: best era5_tol_f1, tiebroken by lowest CV
gtmsn_opt_b <- gtmsn_all_hl |>
  group_by(annual_rp) |>
  filter(era5_tol_f1 == max(era5_tol_f1)) |>
  arrange(mean_cv) |>
  slice_head(n = 1) |>
  ungroup() |>
  mutate(option = "B", selection = "max ERA5 tol F1")

gtmsn_ab <- bind_rows(gtmsn_opt_a, gtmsn_opt_b) |>
  group_by(annual_rp, across(all_of(threshold_cols_gtmsn))) |>
  mutate(selection = if (n() > 1) "both" else selection) |>
  slice_head(n = 1) |>
  ungroup() |>
  arrange(annual_rp, selection) |>
  group_by(annual_rp) |>
  mutate(option = LETTERS[row_number()]) |>
  ungroup() |>
  mutate(config_label = sprintf("RP %.1f %s", annual_rp, option))

# Uniform configs from PRE-filter pool (bypasses must-hit/should-hit)
message("GTMSN uniform refs:")
gtmsn_uniform_ref <- get_uniform_refs_prefilter(
  all_results_gtmsn, threshold_cols_gtmsn,
  primera_lts_gtmsn, postrera_lts_gtmsn,
  target_rp = target_rp_gtmsn, era5_data = gtmsn_era5
)

gtmsn_final <- bind_rows(gtmsn_ab, gtmsn_uniform_ref) |>
  mutate(row_idx = row_number())

# Pre-render GT activation tables for each final config
gtmsn_activation_tables <- lapply(seq_len(nrow(gtmsn_final)), function(i) {
  tbl <- build_trigger_activation_gt(
    gtmsn_final[i, ], trigger_data_gtmsn, df_gtm_sn,
    df_cerf_drought, df_emdat_drought, "GTM",
    eval_start = EVAL_START, eval_end = EVAL_END,
    df_emdat_interp = df_emdat_drought_interp,
    must_hit_years = must_hit_years,
    should_hit_years = should_hit_years,
    sort_by = "activation"
  )
  as.character(gt::as_raw_html(tbl))
})

gtmsn_default_idx <- which.min(abs(gtmsn_final$annual_rp - target_rp_gtmsn))
```

```{r}
#| label: fig-gtmsn-tradeoff-interactive
#| fig-cap: "ERA5 tolerant F1 vs Impact F1 for Guatemala (StartNetwork). Click a circled point to see its trigger activation detail below."

gtmsn_df <- gtmsn_tradeoff$data
gtmsn_bg <- gtmsn_df |> filter(rp_group == "other")
gtmsn_hl <- gtmsn_df |> filter(rp_group != "other")

gtmsn_rp_levels <- levels(gtmsn_df$rp_group)
gtmsn_hl_levels <- setdiff(gtmsn_rp_levels, "other")
gtmsn_hl_colors <- c("#e41a1c", "#377eb8", "#4daf4a", "#984ea3",
                      "#ff7f00", "#a65628")[seq_along(gtmsn_hl_levels)]
gtmsn_colors <- c(setNames(gtmsn_hl_colors, gtmsn_hl_levels), "other" = "grey80")

# Deduplicate labels (exclude U — uniform gets its own label layer)
gtmsn_labels <- gtmsn_final |>
  filter(option != "U") |>
  group_by(era5_tol_f1, impact_f1, rp_group) |>
  summarise(
    label = paste(config_label, collapse = " / "),
    avg_f1 = max(avg_f1),
    .groups = "drop"
  ) |>
  mutate(label = sprintf("%s\navg=%.2f", label, avg_f1))

gtmsn_final_ab <- gtmsn_final |> filter(option != "U")
gtmsn_final_u <- gtmsn_final |> filter(option == "U")

p_gtmsn <- ggplot(mapping = aes(x = era5_tol_f1, y = impact_f1)) +
  geom_point_interactive(
    data = gtmsn_bg,
    aes(tooltip = sprintf("RP %.2f | avg F1 = %.3f | CV = %.3f | all CV = %.3f\nImpact = %.3f | ERA5 tol = %.3f",
                          annual_rp, avg_f1, mean_cv, all_cv, impact_f1, era5_tol_f1)),
    color = "grey80", size = 1.5, alpha = 0.4
  ) +
  {if (nrow(gtmsn_final_u) > 0) geom_point_interactive(
    data = gtmsn_final_u,
    aes(tooltip = sprintf("UNIFORM: RP %.2f | all thresholds = %.1f\navg F1 = %.3f | Impact = %.3f | ERA5 tol = %.3f",
                          annual_rp, .data[[threshold_cols_gtmsn[1]]], avg_f1, impact_f1, era5_tol_f1),
        data_id = as.character(row_idx),
        onclick = sapply(row_idx, make_onclick_js, prefix = "gtmsn")),
    color = "#ffd700", size = 9, shape = 1, stroke = 1.5, show.legend = FALSE
  )} +
  geom_point_interactive(
    data = gtmsn_hl,
    aes(color = rp_group,
        tooltip = sprintf("RP %.2f | avg F1 = %.3f | CV = %.3f | all CV = %.3f\nImpact = %.3f | ERA5 tol = %.3f",
                          annual_rp, avg_f1, mean_cv, all_cv, impact_f1, era5_tol_f1)),
    size = 2.5, alpha = 0.8
  ) +
  geom_point_interactive(
    data = gtmsn_final_ab,
    aes(color = rp_group,
        tooltip = sprintf("RP %.2f %s (%s)\navg F1 = %.3f | CV = %.3f | all CV = %.3f",
                          annual_rp, option, selection, avg_f1, mean_cv, all_cv),
        data_id = as.character(row_idx),
        onclick = sapply(row_idx, make_onclick_js, prefix = "gtmsn")),
    size = 5, shape = 21, fill = "transparent", stroke = 1.2, show.legend = FALSE
  ) +
  geom_label_repel(
    data = gtmsn_labels,
    aes(label = label, color = rp_group),
    size = 2.8, fill = "white", label.size = 0.2,
    show.legend = FALSE, max.overlaps = 30,
    segment.color = "grey50", segment.size = 0.3,
    min.segment.length = 0, force = 5, nudge_y = 0.02
  ) +
  {if (nrow(gtmsn_final_u) > 0) geom_label_repel(
    data = gtmsn_final_u,
    aes(label = config_label),
    size = 2.8, fill = alpha("#ffd700", 0.3), label.size = 0.2, color = "black",
    show.legend = FALSE, max.overlaps = 30,
    segment.color = "grey50", segment.size = 0.3,
    min.segment.length = 0, force = 5, nudge_y = 0.02
  )} +
  scale_color_manual(values = gtmsn_colors, name = "Annual RP") +
  labs(x = "ERA5 Tolerant F1", y = "Impact F1 (EM-DAT)",
       title = "ERA5 vs Impact F1 Tradeoff — Guatemala (StartNetwork)",
       subtitle = "Circles = A (max avg F1) / B (max ERA5) per RP | Yellow halos = uniform (all thresholds equal)") +
  theme_minimal(base_size = 11) +
  theme(legend.position = "right", panel.grid.minor = element_blank())

girafe(ggobj = p_gtmsn,
       options = list(
         opts_hover(css = "cursor:pointer;stroke-width:3;"),
         opts_selection(type = "single", css = "stroke-width:3;"),
         opts_sizing(rescale = TRUE, width = 1)
       ))
```

```{r}
#| label: tbl-gtmsn-config-summary

build_config_summary_gt(
  gtmsn_final, threshold_cols_gtmsn,
  primera_lts_gtmsn, postrera_lts_gtmsn,
  "Guatemala (StartNetwork)",
  top_picks = c("RP 2.9 A", "Uniform thresh 5.8)", "RP 2.7 A")
)
```

**Trigger Activation Detail (per leadtime)**

Click a circled point on the tradeoff plot above to swap the detailed per-leadtime activation table below.

```{r}
#| label: tbl-gtmsn-activation-interactive

gtmsn_divs <- lapply(seq_along(gtmsn_activation_tables), function(i) {
  display <- if (i == gtmsn_default_idx) "block" else "none"
  htmltools::div(
    id = sprintf("gtmsn-tbl-%d", i),
    class = "gtmsn-activation-tbl",
    style = sprintf("display:%s;", display),
    htmltools::HTML(gtmsn_activation_tables[[i]])
  )
})
htmltools::browsable(htmltools::tagList(gtmsn_divs))
```

**Activation Summary**

```{r}
#| label: tbl-gtmsn-activation-summary

obs_by_year_gtmsn <- df_gtm_sn |>
  filter(year >= EVAL_START, year <= EVAL_END) |>
  distinct(year, window, obs_mm)

gtmsn_obs_rps <- bind_rows(
  obs_by_year_gtmsn |> filter(window == "primera") |>
    mutate(obs_rp_pri = (n() + 1) / rank(obs_mm, ties.method = "first")) |>
    select(year, obs_rp_pri),
  obs_by_year_gtmsn |> filter(window == "postrera") |>
    mutate(obs_rp_post = (n() + 1) / rank(obs_mm, ties.method = "first")) |>
    select(year, obs_rp_post)
) |> group_by(year) |> summarise(across(everything(), ~ max(.x, na.rm = TRUE)), .groups = "drop")

cerf_gtmsn <- df_cerf_drought |>
  filter(iso3 == "GTM", year >= EVAL_START, year <= EVAL_END) |>
  distinct(year) |> mutate(cerf = TRUE)

emdat_interp_gtmsn <- df_emdat_drought_interp |>
  filter(iso3 == "GTM", year >= EVAL_START, year <= EVAL_END) |>
  select(year, total_affected_interp)

gtmsn_summary <- tibble(year = years) |>
  mutate(
    priority = case_when(
      year %in% must_hit_years ~ "P1",
      year %in% should_hit_years ~ "P2",
      TRUE ~ ""
    )
  ) |>
  left_join(cerf_gtmsn, by = "year") |>
  mutate(cerf = replace_na(cerf, FALSE),
         cerf_label = if_else(cerf, "\u2713", "")) |>
  left_join(emdat_interp_gtmsn, by = "year") |>
  left_join(gtmsn_obs_rps, by = "year")

for (i in seq_len(nrow(gtmsn_final))) {
  activation <- get_seasonal_activation(gtmsn_final[i, ], trigger_data_gtmsn,
                                         EVAL_START, EVAL_END)
  col_name <- gtmsn_final$config_label[i]
  p_hit <- gtmsn_summary$year %in% activation$primera
  s_hit <- gtmsn_summary$year %in% activation$postrera
  gtmsn_summary[[col_name]] <- case_when(
    p_hit & s_hit ~ "Pr+Pst",
    p_hit ~ "Pr",
    s_hit ~ "Pst",
    TRUE ~ ""
  )
}

gtmsn_config_labels <- gtmsn_final$config_label

gtmsn_summary <- gtmsn_summary |>
  mutate(.any_active = if_any(all_of(gtmsn_config_labels), ~ .x != "")) |>
  arrange(desc(.any_active), year) |>
  select(-.any_active)

gtmsn_display <- gtmsn_summary |>
  select(year, priority, cerf_label, total_affected_interp,
         obs_rp_pri, obs_rp_post, all_of(gtmsn_config_labels))

gtmsn_max_bar <- max(gtmsn_display$total_affected_interp, na.rm = TRUE)

tbl_gtmsn <- gtmsn_display |>
  gt() |>
  cols_label(
    year = "Year", priority = "P", cerf_label = "CERF",
    total_affected_interp = "EM-DAT",
    obs_rp_pri = "Pri", obs_rp_post = "Post"
  ) |>
  fmt_number(columns = c(obs_rp_pri, obs_rp_post), decimals = 1) |>
  sub_missing(columns = c(obs_rp_pri, obs_rp_post), missing_text = "") |>
  text_transform(
    locations = cells_body(columns = total_affected_interp),
    fn = make_bar_transform("#e6550d", gtmsn_max_bar)
  ) |>
  tab_spanner(label = "ERA5 Obs RP", columns = c(obs_rp_pri, obs_rp_post)) |>
  tab_spanner(label = "Activation", columns = all_of(gtmsn_config_labels))

for (col in gtmsn_config_labels) {
  active_rows <- which(gtmsn_display[[col]] != "")
  if (length(active_rows) > 0) {
    tbl_gtmsn <- tbl_gtmsn |>
      tab_style(
        style = list(cell_fill(color = "#d4edda"), cell_text(weight = "bold")),
        locations = cells_body(columns = !!col, rows = active_rows)
      )
  }
}

tbl_gtmsn |>
  tab_style(style = cell_fill(color = "#fde0dd"),
            locations = cells_body(columns = priority, rows = priority == "P1")) |>
  tab_style(style = cell_fill(color = "#fff7bc"),
            locations = cells_body(columns = priority, rows = priority == "P2")) |>
  tab_style(style = cell_fill(color = "#d4edda"),
            locations = cells_body(columns = cerf_label, rows = cerf_label == "\u2713")) |>
  data_color(columns = c(obs_rp_pri, obs_rp_post),
             palette = c("#FDEBD0", "#8B4513"),
             domain = c(1, max(c(gtmsn_display$obs_rp_pri, gtmsn_display$obs_rp_post), na.rm = TRUE)),
             na_color = "white") |>
  cols_align(align = "center") |>
  tab_header(
    title = "Guatemala (StartNetwork): Activation Summary",
    subtitle = "Pr = primera only | Pst = postrera only | Pr+Pst = both seasons"
  ) |>
  tab_options(table.font.size = px(11), data_row.padding = px(2))
```

```{r}
#| label: tbl-gtmsn-final
#| tbl-cap: "Guatemala (StartNetwork) recommended configurations: best average F1 per return period, tiebroken by lowest threshold CV."

gtmsn_final |>
  select(
    config_label, selection,
    any_of(c("p0", "p1", "p2", "s0", "s1")),
    annual_rp, p_seasonal_rp, s_seasonal_rp,
    impact_f1, era5_tol_f1, avg_f1, mean_cv, all_cv
  ) |>
  mutate(
    across(c(impact_f1, era5_tol_f1, avg_f1, mean_cv, all_cv), \(x) round(x, 3)),
    across(c(annual_rp, p_seasonal_rp, s_seasonal_rp), \(x) round(x, 2))
  ) |>
  gt() |>
  cols_align(align = "center") |>
  cols_label(selection = "Criterion") |>
  tab_spanner(label = "Primera thresholds (RP)", columns = starts_with("p")) |>
  tab_spanner(label = "Postrera thresholds (RP)", columns = starts_with("s")) |>
  tab_spanner(label = "Return periods", columns = c(annual_rp, p_seasonal_rp, s_seasonal_rp)) |>
  tab_spanner(label = "Performance", columns = c(impact_f1, era5_tol_f1, avg_f1, mean_cv, all_cv)) |>
  tab_header(
    title = "Guatemala (StartNetwork): Recommended Configurations",
    subtitle = "A = max avg F1 | B = max ERA5 tol F1 | U = uniform (all thresholds equal)"
  )
```

:::


## Recommended Configurations

```{r}
#| label: recommended-configs

# Extract recommended configs by selection criterion, closest to RP 2.9
# HND: prefer "max ERA5 tol F1" or "both"; SLV: prefer "max avg F1" or "both"
pick_rec <- function(df_final, selection_pref, target_rp = 2.9) {
  candidates <- df_final |>
    filter(selection %in% c(selection_pref, "both")) |>
    slice_min(abs(annual_rp - target_rp), n = 1, with_ties = FALSE)
  # Fallback: if no match, take closest RP regardless of selection

  if (nrow(candidates) == 0) {
    candidates <- df_final |>
      slice_min(abs(annual_rp - target_rp), n = 1, with_ties = FALSE)
  }
  # Convert to list for safe scalar extraction
  as.list(candidates[1, ])
}

hnd_rec <- pick_rec(hnd_final, "max ERA5 tol F1")
hnd_alt <- pick_rec(hnd_final, "max avg F1", target_rp = 2.7)
slv_rec <- pick_rec(slv_final, "max avg F1")
gtm_rec <- pick_rec(gtm_final, "max avg F1", target_rp = target_rp_gtm)
gtmsn_rec <- pick_rec(gtmsn_final, "max avg F1", target_rp = target_rp_gtmsn)

# Helper: format thresholds as "LT0=X, LT1=Y, ..."
fmt_thresholds <- function(rec, prefix, n_lts) {
  cols <- paste0(prefix, 0:(n_lts - 1))
  vals <- sapply(cols, function(c) sprintf("%.1f", rec[[c]]))
  paste(sprintf("LT%d = %s", 0:(n_lts - 1), vals), collapse = ", ")
}
```

Based on the tradeoff analysis above, we recommend the following trigger configurations:

**Honduras: `r hnd_rec$config_label`** (`r hnd_rec$selection`)

- Primera thresholds (RP): `r fmt_thresholds(hnd_rec, "p", primera_lts_hnd)`
- Postrera thresholds (RP): `r fmt_thresholds(hnd_rec, "s", postrera_lts_hnd)`
- Seasonal RPs: primera = `r sprintf("%.1f", hnd_rec$p_seasonal_rp)`, postrera = `r sprintf("%.1f", hnd_rec$s_seasonal_rp)`, annual = `r sprintf("%.1f", hnd_rec$annual_rp)`
- Impact F1 = `r sprintf("%.3f", hnd_rec$impact_f1)` | ERA5 tolerant F1 = `r sprintf("%.3f", hnd_rec$era5_tol_f1)` | Avg F1 = `r sprintf("%.3f", hnd_rec$avg_f1)` | CV = `r sprintf("%.3f", hnd_rec$mean_cv)`

Honduras has `r length(impact_yrs_hnd)` EM-DAT impact years in `r EVAL_START`--`r EVAL_END` --- a relatively high event frequency. With this many impact years, the impact F1 scores are tightly clustered among candidate configurations at a given RP, so impact F1 alone does not discriminate well between options. Selecting the max ERA5 tolerant F1 option ensures the trigger is aligned with actual rainfall anomalies, choosing the configuration that best predicts genuinely dry years rather than succeeding on the impact metric by coincidence.

It is worth noting that **`r hnd_alt$config_label`** (`r hnd_alt$selection`) is a strong alternative. At a lower annual RP of `r sprintf("%.1f", hnd_alt$annual_rp)`, this configuration picks up 2012 --- a year missed by the RP 2.9 options --- with an avg F1 of `r sprintf("%.3f", hnd_alt$avg_f1)` and ERA5 tolerant F1 of `r sprintf("%.3f", hnd_alt$era5_tol_f1)`. However, this RP may fall below the target annual return period constraint, implying a higher trigger frequency than operationally desired.

- Primera thresholds (RP): `r fmt_thresholds(hnd_alt, "p", primera_lts_hnd)`
- Postrera thresholds (RP): `r fmt_thresholds(hnd_alt, "s", postrera_lts_hnd)`
- Seasonal RPs: primera = `r sprintf("%.1f", hnd_alt$p_seasonal_rp)`, postrera = `r sprintf("%.1f", hnd_alt$s_seasonal_rp)`, annual = `r sprintf("%.1f", hnd_alt$annual_rp)`
- Impact F1 = `r sprintf("%.3f", hnd_alt$impact_f1)` | ERA5 tolerant F1 = `r sprintf("%.3f", hnd_alt$era5_tol_f1)` | Avg F1 = `r sprintf("%.3f", hnd_alt$avg_f1)` | CV = `r sprintf("%.3f", hnd_alt$mean_cv)`

**El Salvador: `r slv_rec$config_label`** (`r slv_rec$selection`)

- Primera thresholds (RP): `r fmt_thresholds(slv_rec, "p", primera_lts_slv)`
- Postrera thresholds (RP): `r fmt_thresholds(slv_rec, "s", postrera_lts_slv)`
- Seasonal RPs: primera = `r sprintf("%.1f", slv_rec$p_seasonal_rp)`, postrera = `r sprintf("%.1f", slv_rec$s_seasonal_rp)`, annual = `r sprintf("%.1f", slv_rec$annual_rp)`
- Impact F1 = `r sprintf("%.3f", slv_rec$impact_f1)` | ERA5 tolerant F1 = `r sprintf("%.3f", slv_rec$era5_tol_f1)` | Avg F1 = `r sprintf("%.3f", slv_rec$avg_f1)` | CV = `r sprintf("%.3f", slv_rec$mean_cv)`

El Salvador has fewer EM-DAT impact years, making impact F1 a more informative discriminator. The max avg F1 option provides the best balance between capturing impact events and predicting rainfall anomalies. Prioritizing ERA5 skill alone would sacrifice impact detection without sufficient gain in rainfall accuracy to justify the tradeoff.

**Guatemala: `r gtm_rec$config_label`** (`r gtm_rec$selection`)

- Primera thresholds (RP): `r fmt_thresholds(gtm_rec, "p", primera_lts_gtm)`
- Postrera thresholds (RP): `r fmt_thresholds(gtm_rec, "s", postrera_lts_gtm)`
- Seasonal RPs: primera = `r sprintf("%.1f", gtm_rec$p_seasonal_rp)`, postrera = `r sprintf("%.1f", gtm_rec$s_seasonal_rp)`, annual = `r sprintf("%.1f", gtm_rec$annual_rp)`
- Impact F1 = `r sprintf("%.3f", gtm_rec$impact_f1)` | ERA5 tolerant F1 = `r sprintf("%.3f", gtm_rec$era5_tol_f1)` | Avg F1 = `r sprintf("%.3f", gtm_rec$avg_f1)` | CV = `r sprintf("%.3f", gtm_rec$mean_cv)`

**Guatemala (StartNetwork): `r gtmsn_rec$config_label`** (`r gtmsn_rec$selection`)

- Primera thresholds (RP): `r fmt_thresholds(gtmsn_rec, "p", primera_lts_gtmsn)`
- Postrera thresholds (RP): `r fmt_thresholds(gtmsn_rec, "s", postrera_lts_gtmsn)`
- Seasonal RPs: primera = `r sprintf("%.1f", gtmsn_rec$p_seasonal_rp)`, postrera = `r sprintf("%.1f", gtmsn_rec$s_seasonal_rp)`, annual = `r sprintf("%.1f", gtmsn_rec$annual_rp)`
- Impact F1 = `r sprintf("%.3f", gtmsn_rec$impact_f1)` | ERA5 tolerant F1 = `r sprintf("%.3f", gtmsn_rec$era5_tol_f1)` | Avg F1 = `r sprintf("%.3f", gtmsn_rec$avg_f1)` | CV = `r sprintf("%.3f", gtmsn_rec$mean_cv)`


## Appendix: ROC Analysis {.appendix}

The ROC-style analysis below examines how well ERA5 observed rainfall (at various RP thresholds) predicts EM-DAT drought events. Low AUC values confirm the weak relationship between rainfall severity ranking and humanitarian impact, further supporting the hybrid optimization approach used in this chapter.

::: {.panel-tabset}

### Honduras

```{r}
#| label: fig-roc-hnd
#| fig-cap: "ROC-style curve for Honduras: ERA5 rainfall RP threshold vs EM-DAT drought detection."

roc_hnd <- plot_impact_roc(df_hnd, df_emdat_drought, "HND",
                            eval_start = EVAL_START, eval_end = EVAL_END)
roc_hnd$plot
```

### El Salvador

```{r}
#| label: fig-roc-slv
#| fig-cap: "ROC-style curve for El Salvador: ERA5 rainfall RP threshold vs EM-DAT drought detection."

roc_slv <- plot_impact_roc(df_slv, df_emdat_drought, "SLV",
                            eval_start = EVAL_START, eval_end = EVAL_END)
roc_slv$plot
```

### Guatemala

```{r}
#| label: fig-roc-gtm
#| fig-cap: "ROC-style curve for Guatemala: ERA5 rainfall RP threshold vs EM-DAT drought detection."

roc_gtm <- plot_impact_roc(df_gtm, df_emdat_drought, "GTM",
                            eval_start = EVAL_START, eval_end = EVAL_END)
roc_gtm$plot
```

### Guatemala (StartNetwork)

```{r}
#| label: fig-roc-gtmsn
#| fig-cap: "ROC-style curve for Guatemala (StartNetwork): ERA5 rainfall RP threshold vs EM-DAT drought detection."

roc_gtmsn <- plot_impact_roc(df_gtm_sn, df_emdat_drought, "GTM",
                              eval_start = EVAL_START, eval_end = EVAL_END)
roc_gtmsn$plot
```

:::
