---
title: "CADC Trigger Technical Exploration App"
output:
  flexdashboard::flex_dashboard:
     orientation: rows
     vertical_layout: scroll
     # horitzonal_layout: fill
date: "2023-11-22"
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r, echo=FALSE, include=F}
library(tidyverse)
library(gghdx)
library(gt)
library(arrow)
library(janitor)
library(broom)
library(readxl) # just for activity table
library(ggiraph) # just for activiity
library(glue)
# gghdx()

forecast_source <-  "mars"

df_cropland_lte_vhi_threshold_dc <- read_parquet("shinyAppData/df_cropland_lte_vhi_threshold_dc.parquet") 
df_ecmwf_zonal <- read_parquet("shinyAppData/df_ecmwf_zonal.parquet")
# df_ecmwf_zonal <- read_parquet("shinyAppData/df_ecmwf_mars_zonal.parquet") 
df_iri_adm0_pre <- read_parquet("shinyAppData/df_iri_adm0_pre.parquet") 
# targets::tar_load(df_ecmwf_zonal_all) # this used to be input for next step

df_ecmwf_zonal_all <- df_ecmwf_zonal %>% 
    mutate(
    valid_mo =month(valid_date),
    # lt= lt- 1
  ) %>% 
    filter(stat== "mean")

targets::tar_load(df_era5_mo)


adjustable_leadtimes2 <-  function(publication_mo=find_pub_mos(5),valid_mo=5){
  publication_mo <- as.numeric(publication_mo)
  valid_mo <- as.numeric(valid_mo)
  multi_yr_pub <- publication_mo[1]>publication_mo[length(publication_mo)]
  if(multi_yr_pub){
    dec_idx <- which(!publication_mo>lag(publication_mo))-1
    publication_mo[dec_idx] # issue if skip Dec?
    prev_year_mos <- publication_mo[1:dec_idx]
    prev_year_dates <- as_date(paste0("2020-", formatC(prev_year_mos,
                                    digits = 2,
                                    flag = "0",
                                    width = 2),"-01"))
    next_year_mos <-  publication_mo[(dec_idx+1):length(publication_mo)]
    next_year_dates <- as_date(paste0("2021-", formatC(next_year_mos,
                                    digits = 2,
                                    flag = "0",
                                    width = 2),"-01"))
    all_dates <- c(prev_year_dates,next_year_dates)
    min_pub_date <- min(all_dates)
    # not designed yet for multi yr validation
    min_valid_mo <- min(as.numeric(valid_mo))
     min_valid_date <- as_date(paste0("2021-", formatC(min_valid_mo,
                                    digits = 2,
                                    flag = "0",
                                    width = 2),"-01"))
     # this should be improved -- go direct from days to months rather than arith
    lts_days <- (min_valid_date- all_dates)+1
    # for some reaso counting 30 days as 0 months -- 
    # therefore add 1 to make it recognize as month = 1
    # lts_mos <- as.period(lts_days)%/% months(1)
    lts_mos <- round(lts_days/30)
    # as.period(31,"days")%/% months(1)
  }
  if(!multi_yr_pub){
    mon_mo <-  as.numeric(publication_mo)
    valid_start <- min(as.numeric(valid_mo))
    lts_mos <- return(valid_start- mon_mo)
  }
  return(lts_mos)
}
adjustable_leadtimes2_reactive <- reactive({
  adjustable_leadtimes2(publication_mo = as.numeric(input$winA_mon),
                        valid_mo = as.numeric(input$winA_forecast))
})
# adjustable_leadtimes2(publication_mo = find_pub_mos(5),valid_mo = 5)
adjustable_leadtimes <-  function(monitor_months, forecast_months){
  # browser()
   
  mon_mo <-  as.numeric(monitor_months)
  forecast_start <- min(as.numeric(forecast_months))
  return(forecast_start- mon_mo)
}

# Constructing Quadratic Formula
quad_eq <- function(a,b,c){
  if(delta(a,b,c) > 0){ # first case D>0
    x_1 = (-b+sqrt(delta(a,b,c)))/(2*a)
    x_2 = (-b-sqrt(delta(a,b,c)))/(2*a)
    result = c(x_1,x_2)
    return(result)
  }
  else if(delta(a,b,c) == 0){ # second case D=0
    x = -b/(2*a)
  }
  else {"There are no real roots."} # third case D<0
}
# Constructing delta
delta<-function(a,b,c){
  b^2-4*a*c
}

plt_color <- c(non_drought =hdx_hex("mint-hdx"),drought = hdx_hex("tomato-hdx"))

load_pub_mo_list <- function(ecmwf_source){
  if(ecmwf_source=="mars"){
    lt <- 6
  }
  if(ecmwf_source=="cds"){
    lt <- 5
  }
  set_names(c(1:12),
            month(c(1:12),label=T,abbr=T)
  ) %>% 
    map(\(mo_int){
      start_mo_int <- mo_int-lt
      seq_mo_int <-  start_mo_int:mo_int
      mo_seq<- ifelse(seq_mo_int<=0, seq_mo_int+12, seq_mo_int)
      return(mo_seq)
    }
    )
}
  
# provide valid mo's and return possible publication months that could be used
# to monitor status
find_pub_mos <-  function(x=c(5,6,7,8)){
  x <- as.numeric(unname(x))
  avail_mo_list <- load_pub_mo_list(ecmwf_source = forecast_source)
  month_diffs <- diff(c(x, x[1] + 12))
  
  # Find the index of the maximum difference
  max_diff_index <- which.max(month_diffs)
  
  # The maximum month is the one following the index with the maximum difference
  max_month <- x[max_diff_index]
  max_month_lab <- month(max_month,label=T, abbr=T)
  pub_mos <- avail_mo_list[[max_month_lab]]
  ret <- pub_mos[!(pub_mos %in% x[2:length(x)])]
  
  # hacky solution to fix the fact that if (for example)
  # we are monitoring:  5,6,7 we want to exclude May
  # but if just monitoring 5 there is nothing to exclude
  if(forecast_source=="mars"){
    if(length(x)==1){
      ret <- pub_mos
    } else{
      ret <- pub_mos[!(pub_mos %in% x[2:length(x)])]
    }
    
  }
  return(ret)
}

find_pub_mos_reactive <-  reactive({
  find_pub_mos(x = input$winA_forecast)
})

```


Inputs {.sidebar}
============================

Public ECMWF data provides a 6 months of leadtime for every forecast (including pub month). Therefore select the period you are interested in monitoring  and the possible monitoring dates will be made available. The ECMWF SEAS51 data with higher resolution and 7 months of leadtime has been requested by the CHD, so this will be updated when the data is made available.


```{r windowParams, echo=F,eval=F,out.width="100%"}
# Window & Countries
# Define reactive function
inputPanel(
  selectInput(inputId = "num_windows",
              choices = 1:3,
              selected = c(1),
              label = "Number of windows to define/monitor"
  ),
  checkboxGroupInput(inputId = "sel_country",
                     choices = c("El Salvador","Guatemala","Honduras","Nicaragua"),
                     selected = c("El Salvador","Guatemala","Honduras","Nicaragua"),
                     inline=T,
                     label = "Select Country to display"),
)
```



```{r temporalSel, echo=FALSE,out.width="100%"}

# inputPanel(
    selectInput(inputId = "num_windows",
              choices = 1:3,
              selected = c(1),
              label = "Number of windows to define/monitor"
  )
  checkboxGroupInput(inputId = "sel_country",
                     choices = c("El Salvador","Guatemala","Honduras","Nicaragua"),
                     selected = c("El Salvador","Guatemala","Honduras","Nicaragua"),
                     inline=T,
                     label = "Select Country to display")


  checkboxGroupInput(inputId = "winA_forecast",
                     choices = c(1:12) %>%
                       set_names(month(1:12,label=T,abbr=T)),
                     selected = c(5,6,7,8),
                     inline=F,
                     label = "Step 1: Select time period/window of concert")
  
  
  # issue that this is rendering lazily
  # monitor_months <- reactive({find_pub_mos(x=input$winA_forecast)})
  renderUI({
    browser()
    
    # monitor_months <- find_pub_mos(x=input$winA_forecast)
    monitor_months <- find_pub_mos_reactive()
    cat(monitor_months,"\n")
    checkboxGroupInput(
      inputId= "winA_mon",
      label = "2. Here are the available months we can monitor:",
      choices = monitor_months %>% set_names(month(monitor_months,label=T,abbr=T)),
      selected = monitor_months
    )
  })

  renderUI({
    if(forecast_source=="cds"){
      lts_tweak = adjustable_leadtimes(input$winA_mon, input$winA_forecast)
    }
    if(forecast_source=="mars"){
      # lts_tweak = adjustable_leadtimes2(as.numeric(input$winA_mon), as.numeric(input$winA_forecast) )
      lts_tweak = adjustable_leadtimes2_reactive()
      }
    # "Tweak Leadtimes",
    lts_tweak %>%
      sort() %>%
      map(\(lt){
        sliderInput(
          inputId = paste0("slider_", lt),
          label = paste("Adjust Leadtime ", lt),
          min = 1, max = 30, value = 4  # Adjust min, max, and value as needed
        )

      })
})
  actionButton("execute", "Generate data")
  
conditionalPanel(condition = "input.num_windows >= 2",
                 inputPanel(
                   
                   checkboxGroupInput(inputId="winB_forecast",
                                      choices = c(1:12) %>% set_names(month(1:12,label=T,abbr=T)),
                                      selected = c(9,10,11),
                                      inline=F, 
                                      label = "Window B Forecast Period"),
                   renderUI({
                     
                     monitor_months <- find_pub_mos(x=input$winB_forecast)
                     # cat(monitor_months,"\n")
                     checkboxGroupInput(
                       inputId= "winB_mon",
                       label = "2. Here are the available months we can monitor:",
                       choices = monitor_months %>% set_names(month(monitor_months,label=T,abbr=T)),
                       selected = monitor_months
                     )
                   }
                   )
                 )
)
conditionalPanel(condition = "input.num_windows == 3",
                 inputPanel(
                   
                   checkboxGroupInput(inputId="winC_forecast",
                                      choices = c(1:12) %>% set_names(month(1:12,label=T,abbr=T)),
                                      selected = c(5,6,7),
                                      inline=T, 
                                      label = "Pre Alert Period"),
                   renderUI({
                     monitor_months <- available_leadtime_months(input$winC_forecast)
                     checkboxGroupInput(
                       inputId= "winC_mon",
                       label = "Select Monitoring Period",
                       choices = monitor_months %>% set_names(month(monitor_months,label=T,abbr=T)),
                       selected = monitor_months
                     )}
                     )
                   )
)

```



```{r eval=TRUE,echo=F}
df_win1 <- eventReactive(input$winA_mon,{
  cat(input$winA_forecast,"\n")
  df_ecmwf_win_filt1 <- df_ecmwf_zonal_all %>% 
    filter(adm0_es %in% input$sel_country) %>% 
    group_by(adm0_es,pub_date) %>% 
    filter(
      month(pub_date) %in% input$winA_mon,
      valid_mo %in% input$winA_forecast
    ) 
  
  df_ecmwf_win_filt2 <- df_ecmwf_win_filt1 %>% 
    group_by(adm0_es, pub_date) %>% 
    filter(
      all(input$winA_forecast %in% valid_mo)
    )
  # browser()
  df_ecmwf_win_filt2 %>% 
    summarise(
      mm = sum(mm),
      lt= min(lt),
      .groups = "drop"
      
    ) %>% 
    mutate(
      yr_date =floor_date(pub_date, "year")
    )})
```




```{r, echo=F}


# dynamically grab the input values from the sliders
gather_slider_values <- reactive({
  if(forecast_source == "cds"){
  lts_tweak = adjustable_leadtimes(
    input$winA_mon, 
    input$winA_forecast) %>% 
    sort()  
  }
  if(forecast_source=="mars"){
      lts_tweak = adjustable_leadtimes2(
    input$winA_mon, 
    input$winA_forecast) %>% 
    sort()  
  }
  # go through each of the available leadtimes and take the slider value
  set_names(lts_tweak,lts_tweak) %>% 
    map(\(lt){
      input[[paste0("slider_", lt)]]
    })
  
})

dynamic_rps <- reactive({

  l_rps <- gather_slider_values()

  df_win_long <- df_win1() %>% 
    select(-pub_date) 
  
   ldf_rps <- l_rps %>% 
    imap(
      \(rp,nm){
        q_rp <- 1/as.numeric(rp)
        df_win_long %>% 
          filter(
            lt==nm
          ) %>% 
          group_by(adm0_es) %>% 
          reframe(
            !!sym(as.character(nm))  := quantile(mm,q_rp)
          )
      }
    )
  
  purrr::reduce(ldf_rps,left_join) 
  
  })


# event based on `button`
apply_dynamic_rps <- eventReactive(input$execute,{
  df_thresh_wide <- dynamic_rps()
  df_win <- df_win1()
  df_thresh_long<- df_thresh_wide %>%
    pivot_longer(
      cols= matches("\\b[0-6]\\b"),
      names_to ="lt",values_to = "q_ind"
    ) %>%
    mutate(
      lt= as.numeric(lt)
    )

   df_full <- df_win %>%
    left_join(
      df_thresh_long
    ) %>%
    mutate(
      lgl_flag = mm<q_ind
    )
  df_overall_activation_rate <- df_full %>%
    group_by(adm0_es,yr=year(pub_date)) %>%
    summarise(
      lgl_flag = any(lgl_flag)
    ) %>%
    summarise(
      ar_overall= mean(lgl_flag),
      rp_overall =1/ar_overall,.groups="drop"
    )

    rp_by_lt_indiv <- df_thresh_wide %>%
    left_join(
      df_overall_activation_rate
    )
    return(
      list(
        rp_by_lt_indiv= rp_by_lt_indiv,
        df = df_full
      )
    )
})
# apply_dynamic_rps <- reactive({
#   df_thresh_wide <- dynamic_rps()
#   df_win <- df_win1()
#   df_thresh_long<- df_thresh_wide %>%
#     pivot_longer(
#       cols= matches("\\b[0-6]\\b"),
#       names_to ="lt",values_to = "q_ind"
#     ) %>% 
#     mutate(
#       lt= as.numeric(lt)
#     )
#   
#    df_full <- df_win %>% 
#     left_join(
#       df_thresh_long
#     ) %>% 
#     mutate(
#       lgl_flag = mm<q_ind
#     ) 
#   df_overall_activation_rate <- df_full %>% 
#     group_by(adm0_es,yr=year(pub_date)) %>% 
#     summarise(
#       lgl_flag = any(lgl_flag)
#     ) %>% 
#     summarise(
#       ar_overall= mean(lgl_flag),
#       rp_overall =1/ar_overall,.groups="drop"
#     )
#   
#     rp_by_lt_indiv <- df_thresh_wide %>% 
#     left_join(
#       df_overall_activation_rate
#     )
#     return(
#       list(
#         rp_by_lt_indiv= rp_by_lt_indiv,
#         df = df_full
#       )
#     )
# })



df_era_seas_win <-  reactive({
  df_era_filt<- df_era5_mo %>%
    clean_names() %>% 
    group_by(adm0_es=adm0_name,yr_date=floor_date(date, "year")) %>%
    filter(
      month(date) %in% input$winA_forecast
    ) %>% 
    summarise(
      mm_obs= sum(value)*1000
    ) 
  dfj<- df_win1() %>% 
    left_join(
      df_era_filt
    )
  
  df_r2 <- dfj %>% 
    group_by(adm0_es,lt) %>% 
    nest(data= c(-lt,-adm0_es) )%>% 
    mutate(
      corr_spear = map(data ,~cor.test(.x$mm,.x$mm_obs)),
      tidy =map(corr_spear,tidy),
      glanced = map(corr_spear,glance)
    ) %>% 
    unnest(tidy) %>% 
    select(adm0_es, lt, estimate)
  dfj %>% 
    left_join(df_r2)
  
})


```



# Dynamic Thresholds 

```{r, echo=F}
render_gt(
  apply_dynamic_rps()$rp_by_lt_indiv %>% 
    gt() %>% 
    cols_label(
      adm0_es="Country" ,
      ar_overall="Activation rate (overall)" ,
      rp_overall="Return period (overall)"
    ) %>% 
    tab_spanner(
      label = "Thresholds by LT",
      columns = any_of(c("0","1","2","3","4","5","6"))
    ) %>%
    fmt_number(columns = any_of(c("0","1","2","3","4","5","6")),decimals=0) %>% 
    fmt_number(columns = c("rp_overall"),decimals =2) %>% 
    fmt_percent(columns = c("ar_overall"),decimals =0) 
)
```
Column {.tabset}
-----------------------------------------------------------------------
### Historical

```{r, echo=F}
renderPlot({
  df_p <- apply_dynamic_rps()$df
  df_p %>% 
    ggplot(
      aes(x= pub_date, y= mm, color=lgl_flag)
    )+
    geom_point()+
        scale_color_manual(values =unname(plt_color))+
    geom_hline(
      data = . %>% 
        distinct(adm0_es,lt,q_ind),
      aes(yintercept = q_ind)
    )+
    scale_x_date(
      date_breaks = "5 year",
      date_labels = "%y"
    )+
    # geom_text(
    #   data= . %>% 
    #     filter(lgl_flag),
    #   aes(x=init_valid_date, y= mm-50,label = format(init_valid_date,"%y"))
    # )+
    theme(
      axis.title.x = element_blank(),
      axis.text.x = element_text(angle=90),
      legend.position  = "none",panel.background = element_rect(fill=NA, color="lightgrey")
    )+
    facet_grid(row=vars(lt), cols = vars(adm0_es))
  
}, height=650)

renderPlot({
  df_p <- apply_dynamic_rps()$df
  df_p %>% 
  group_by(
    adm0_es,yr_date,lt
  ) %>% 
  summarise(
    flags_per_lt = sum(lgl_flag),
    .groups="drop"
  ) %>% 
  # mutate(
  #   lt = as_factor(lt),
  #   lt = fct_relevel(lt, "1","2","3")
  # ) %>% 
  ggplot(
    aes(x= yr_date, y= flags_per_lt,fill=reorder(lt,-lt))
  )+
  geom_bar(stat= "identity")+
      scale_x_date(
      date_breaks = "5 year",
      date_labels = "%y"
    )+
  facet_grid(cols =vars(adm0_es))+
  theme(
      axis.title.x = element_blank(),
      axis.text.x = element_text(angle=90),
      # legend.position  = "none",
      panel.background = element_rect(fill=NA, color="lightgrey")
    )
},height=650
)
```

### Leadtime Correlation

```{r, echo=F}
# input.winA_forecast

renderPlot({
  df_era_seas_plot <- df_era_seas_win()
  
  title_valid_mo <- glue_collapse(month(as.numeric(input$winA_forecast),label=T, abbr=T),"-")
  
  max_y <- max(df_era_seas_plot$mm_obs,na.rm=T)
  
  df_era_seas_plot %>% 
    ggplot(
      aes(x= mm, y= mm_obs)
    )+
    geom_point(alpha=0.5)+
    geom_abline (slope=1, linetype = "dashed", color="Red")+
    # geom_label(data= . %>% distinct(adm0_es,lt,estimate),
    #            aes(label = paste0("r2=",round(estimate,2)))
    #            ,x = 900,y=900)+
    geom_text(
      data= . %>%
        distinct(adm0_es, lt, estimate),
      aes(label= paste0("R2: ",round(estimate,2))), x= 600,y=(max_y-200)
    )+
    facet_grid(
      rows= vars(adm0_es),
      cols = vars(lt)
    )+
    labs(
      title = "Forecast vs Observed by LT",
      subtitle =title_valid_mo,
      x= "ECMWF SEAS 51 Prediction (mm)",
      y= "ERA5 Historical Observation (mm)"
    )
})

```


# Leadtime Bias

## Boxplot

```{r eval=T,echo=F}

# tar_load(df_ecmwf_zonal)
# tar_load(df_era5_mo)
# df_ecmwf_zonal_all <- df_ecmwf_zonal_all %>% 
#     mutate(
#     valid_mo =month(valid_date),
#     lt= lt- 1
#   ) %>% 
#     filter(stat== "mean")

renderPlot({
 df_win1() %>% 
  ggplot(
    aes(x= adm0_es, y= mm, fill=as_factor(lt))
  )+
  geom_boxplot(color="black")
})
  
```

# Performance against observed

How do we define a drought "event" (True Positive)?

```{r eval=T, echo=F, fig.width=10}

fluidRow(
  column(5, offset = 1, style='padding:0px;' ,
         selectInput(inputId = "sel_observed",
                     label = "Define drought with VHI or Rainfall",
                     choices = c(`VHI (ASIS)` = "VHI",`Rainfall (ERA5)`= "Rainfall"),
                     selected = "Rainfall")
  ) #\ close col
  ,column(5, offset = 0, style='padding:0px;', 
          conditionalPanel(condition = "input.sel_observed == 'Rainfall'",
                           sliderInput(
                             inputId = "define_tp_era5",
                             label = "Whats a TP",
                             min = 1,
                             max = 20,
                             value = 4,
                             step = 1
                           )
                           
          )
  ), #\ close col
  column(5, offset = 0, style='padding:0px;', 
  conditionalPanel(condition = "input.sel_observed == 'VHI'",
                   column(5, offset = 0, style='padding:10px;', 
                   sliderInput(inputId = "vhi_thresh_perf", label = "VHI threshold:",
                               min = 0, max = 1, value = 0.35, step = 0.05)
                   ),
                   column(5, offset = 0, style='padding:10px;', 
                   sliderInput(inputId = "vhi_pct_perf", label = "% Cropland threshold:",
                               min = 0, max = 1, value = 0.25, step = 0.05)
                   ),
                   column(5, offset = 0, style='padding:10px;', 
                   checkboxGroupInput(
                     inputId = "vhi_months", label = "Months (ASIS)",
                     choices = c(6,7,8,9,10,11) %>% set_names(month(c(6,7,8,9,10,11),abbr=T,label=T)),
                     selected=7,inline=T
                               
                   )
                   )
  ) #\ close col
)
)


df_vhi_seas <- reactive({

  df_vhi_class <- df_cropland_lte_vhi_threshold_dc %>%
    filter(
      # abs(threshold-0.35)<0.01
      abs(threshold-input$vhi_thresh_perf)<0.01
    ) %>% 
    mutate(
      date = as_date(paste0(date,"-01"))
    ) %>% 
    filter(
      month(date) %in% input$vhi_months
    ) %>% 
    mutate(
      yr_date =floor_date(date,"year"),
      lgl_event = pct_crop_pixels_lte_thresh>=input$vhi_pct_perf
    ) %>% 
    ungroup()
  
    df_win1() %>% 
      ungroup() %>% 
    inner_join(
      df_vhi_class
    )
  
})



# obs_event <- 0.25

thresh_seq<- seq(0,
                 1,
                 by=0.01)

performance_colors <- c(
  TP = hdx_hex("mint-hdx"),   # Light green for True Positives
  FP = "darkred",   # Red for False Positives (most severe)
  FN = "tomato",   # Lighter red for False Negatives
  TN = "green" ,   # Dark green for True Negatives
  precision ="cyan"
)

# l_rps = c(`1` = 3,`2` =4,`3`=4)
dynamic_rp_tbl <- reactive({
  l_rps <- gather_slider_values()
  ldf_rps <- l_rps %>% 
    imap(
      \(rp,nm){
        q_rp <- 1/as.numeric(rp)
        tibble(
          lt = as.numeric(nm),
          threshold=q_rp
        )
      }
    ) %>% 
    list_rbind()
})
# library(ggiraph)

renderPlot({
  if(input$sel_observed=="Rainfall"){
  df_era_seas_ranked <- df_era_seas_win() %>% 
  group_by(adm0_es,lt) %>% 
  mutate(
    mm_obs_rank=dplyr::percent_rank(mm_obs),
    mm_forecast_rank = dplyr::percent_rank(mm)
  ) %>% 
  ungroup()


df_event_class <- df_era_seas_ranked %>% 
  mutate(
    lgl_event = mm_obs_rank <= 1/input$define_tp_era5
  )
  }
  if(input$sel_observed=="VHI"){
    df_event_class <- df_vhi_seas() %>% 
      group_by(adm0_es,lt) %>% 
      mutate(
        mm_forecast_rank = dplyr::percent_rank(mm)
      ) %>% 
      ungroup()
    
  }
  
  
df_perf <- thresh_seq %>% 
  map(\(thresh_temp){
    df_event_class %>% 
      mutate(
        lgl_thresh_forecast = mm_forecast_rank <= thresh_temp,
        TP = lgl_thresh_forecast & lgl_event,
        FP = lgl_thresh_forecast & !lgl_event,
        TN = !lgl_thresh_forecast & !lgl_event,
        FN = !lgl_thresh_forecast & lgl_event
        
      ) %>% 
      group_by(adm0_es, lt) %>% 
      summarise(
        TP = sum(TP,na.rm=T),
        FP= sum(FP,na.rm=T),
        TN = sum(TN,na.rm=T),
        FN= sum(FN,na.rm=T),
        precision = TP/(TP+FP),
        .groups = "drop"
      ) %>% 
      mutate(
        threshold_pctile = thresh_temp
      )
  }
  ) %>% 
  list_rbind()
perf_counts_long <-  df_perf %>%
  pivot_longer(
    cols = c(TP,FP,TN,FN),
    names_to = "metric",
    values_to = "value"
  ) 
# perf_counts_long2 <-  df_perf %>%
#   pivot_longer(
#     cols = c(TP,FP,TN,FN,precision),
#     names_to = "metric",
#     values_to = "value"
#   ) %>% 
#   mutate(
#     value = if_else(metric=="precision",round(value,2),value)
#   )
# df_vline <- perf_counts_long2 %>% 
#   left_join(
#     lt_thresh_tb
#   ) %>% 
#   mutate(
#     thresh_diff = threshold_pctile-0.15
#   ) %>% 
#   filter(
#    abs(thresh_diff)==min(abs(thresh_diff)) 
#    ) %>% 
#   mutate(
#     label = glue("{metric}: {value}\n")
#   ) %>% 
#   group_by(adm0_es,lt,threshold) %>% 
#   summarise(
#     label = glue_collapse(label,sep="\n")
  # )




perf_counts_long %>% 
  ggplot()+
  geom_line(
    aes(x= threshold_pctile,
        y= value,
        color= metric
      
        )
  )+
  scale_color_manual(values=performance_colors)+
  facet_grid(
    rows= vars(adm0_es),
    cols = vars(lt)
  )+
  geom_line(
    data= df_perf %>% 
      mutate(
        metric="precision",
        value = precision *50
        ) 
      ,
    aes(x= threshold_pctile, y= value, color= metric)
  )+
  # geom_vline_interactive(
  #   data= df_vline, aes(xintercept = threshold,tooltip=label)
  # )+
  scale_y_continuous( sec.axis = sec_axis(~./50, name = "precision"))+
  scale_x_reverse(labels=scales::label_percent(), breaks=seq(0,1,.05))+
  theme(
    panel.background = element_rect(fill=NA, color="black"),
    axis.text.x = element_text(angle = 90)
  )+
  labs(x= "threshold (≤)")
# girafe(ggobj = gp,width=10)


}, height = 700)


```

# Activity Timeline Plot
```{r plot-timeline, echo=F, fig.height=20}

fp <- file.path(Sys.getenv("AA_DATA_DIR"),
          "private",
          "processed",
          "lac",
          "cadc_partner_activity_matrix.xlsx")

dfa <- read_excel(fp) %>% 
    arrange(
    window,agency,adm0_es
  )

p_activities <- dfa %>% 
      pivot_longer(cols = latest_mo:implement_mo
      ) %>% 
  arrange(adm0_es) %>% 
      mutate(
        activity = trimws(activity),
        month = month(value,label=T, abbr= T),
        agency = case_when (
          str_detect(agency,"PAHO|WHO")~"PAHO/WHO",
          .default = agency),
        agency = fct_relevel(agency,"FAO","WFP","PAHO/WHO","UNICEF"),
        window = ifelse(window=="A","Window A (Primera)\nMJJJAS","Window B (Postrera)\nSON")
      ) %>% 
  mutate(
    activity = as_factor(activity),
    # activity = fct_reorder(activity,adm0_es)
  ) %>% 
      ggplot(
        aes(x=  activity,y = month, color = adm0_es, group=activity)
      )+
      geom_line()+
  scale_color_brewer(palette = "Spectral")+
      geom_point_interactive(
        aes(tooltip= str_wrap(activity,80))
      )+
      facet_grid(cols= vars(window),
                 rows= vars(agency),
                 scales = "free"
                 )+
      coord_flip()+
     labs(title = "Proposed AA Activities",
          subtitle = "Central American Dry Corridor")+
      theme(
        axis.text.y = element_blank(),
        axis.title.x = element_blank(),
        axis.text.x = element_text(angle=90),
        panel.grid.minor = element_blank(),
        panel.grid.major = element_blank(),
        panel.background = element_rect(fill=NA,color="grey"),
        
      )



renderGirafe({
  girafe(ggobj= p_activities)
})
```

# Scrap

```{r eval=F,echo=F}
perf_counts_long <-  df_perf %>%
  select(-precision) %>% 
  pivot_longer(
    cols = c(TP,FP,TN,FN),
    names_to = "metric",
    values_to = "value"
  ) 

pal_perf2 <- c(TP= "#0C7182", TN= "#A7D2D8", FP= "#E0D796",FN= "#A84E0B")
perf_counts_long %>% 
  group_by(adm0_es, lt,threshold_pctile) %>% 
  mutate(
    pct = value/sum(value)
  ) %>% 
  ungroup() %>% 
  ggplot()+
  geom_area(
    aes( x= threshold_pctile, y= pct, fill= metric), color="black"
  )+
  scale_fill_manual(values=pal_perf2)+
  scale_x_reverse(labels = scales::label_percent())+
  facet_grid(
    rows=vars(adm0_es),
    cols =vars(lt)
  )
```



```{r, echo=F}
df_ecmwf_zonal <- df_ecmwf_zonal %>% 
  mutate(
    seas_gen = case_when(
      month(init_valid_date)==5 ~"MJJ",
      month(init_valid_date)==6 ~"JJA",
      month(init_valid_date)==9 ~"SON",
    )
  )%>% 
  filter(!is.na(seas_gen))

```






```{r, echo=F}
df_ecmwf_zonal <- df_ecmwf_zonal %>% 
  mutate(
    seas_gen = case_when(
      month(init_valid_date)==5 ~"MJJ",
      month(init_valid_date)==6 ~"JJA",
      month(init_valid_date)==9 ~"SON",
    )
  )%>% 
  filter(!is.na(seas_gen))



```

- This App is meant to allow the user to explore trigger thresholds and better understand how adjusting parameters effects the framework.
- **All default set values reflect the current state of recommendations.**
  
  # Select Seasonal Rainfall Parameters
  
  Choose the desired RP & monitoring windows. The values here effect the thresholds and historical timeseries plots below for both **ECMWF** & **IRI**. As IRI only includes 6 years of data any values returned for an RP ≥ 6 years are not properly calculated.

The thresholds based on the desired return period are provided for each window. For `JJA` and `SON` the equivalent RP & thresholds for **either** window activating is also provided.

**By default** the `RP` is set to 3 years.

```{r ecmwf, echo=FALSE,out.width="100%"}
inputPanel(
  sliderInput(inputId = "ecmwf_rp", label = "Desired RP:",
              min = 0, max = 20, value = 3, step = 1),
  checkboxGroupInput(inputId = "w1_monitor",
                     choices = c("Jan"=1,"Feb"=2,"Mar"=3,"Apr"=4),
                     selected = c(1,2,3,4),
                     label = "Window 1 monitoring",
  ),
  checkboxGroupInput(inputId = "w2_monitor",
                     choices = c("Feb"=2,"Mar"=3,"Apr"=4,"May"=5),
                     selected = c(2,3,4),
                     label = "Window 2 monitoring",
  ),
  checkboxGroupInput(inputId = "w3_monitor",
                     choices = c("May"=5,"June"=6,"July"=7,"Aug"=8),
                     selected = c(5,6,7),
                     label = "Window 3 monitoring",
  )
  
)

df_rp_q <- reactive({
  q_rp <- 1/input$ecmwf_rp
  
  eq_probs <- quad_eq(a = -1, b = 2, c = -q_rp)
  q_jrp <- eq_probs[1]
  rp_jp <- 1/eq_probs[1]
  
  df_ecmwf_zonal_filt_mins <- df_ecmwf_zonal %>% 
    filter(
      (seas_gen == "MJJ" & month(date) %in% input$w1_monitor)|
        (seas_gen == "JJA" & month(date) %in% input$w2_monitor)|
        (seas_gen == "SON" & month(date) %in% input$w3_monitor)
    ) %>%
    group_by(
      adm0_es,init_valid_date,init_year,seas_gen
    ) %>% 
    summarise(
      mm=min(mm),.groups="drop"
    )
  
  df_ecmwf_filt_quantiles <-  df_ecmwf_zonal_filt_mins %>% 
    group_by(
      adm0_es,seas_gen
    ) %>% 
    summarise(
      q_ind = quantile(mm,q_rp),
      q_jp = quantile(mm,q_jrp),
      .groups="drop"
      
    ) 
  
  df_full <- df_ecmwf_zonal_filt_mins %>% 
    left_join(
      df_ecmwf_filt_quantiles
    ) %>% 
    mutate(
      lgl_flag = mm<q_ind
    )
  list(
    df= df_ecmwf_filt_quantiles,
    indiv_prob = input$ecmwf_rp,
    joint_prob = round(rp_jp,1),
    df_full = df_full
  )
  
})


render_gt({
  gt_ecmwf_filt_quantiles <- df_rp_q()$df %>%
    ungroup() %>%
    pivot_wider(
      names_from=seas_gen,
      values_from = q_ind:q_jp
    ) %>%
    select(
      adm0_es, ends_with("MJJ"),
      ends_with("JJA"),
      ends_with("SON")
    ) %>%
    gt() %>%
    cols_hide(columns = "q_jp_MJJ") %>%
    cols_label(
      adm0_es = "Country",
      q_ind_MJJ = paste0(df_rp_q()$indiv_prob," year RP (weighted batches)"),
      q_ind_JJA= paste0(df_rp_q()$indiv_prob," year RP (weighted batches)"),
      q_jp_JJA= paste0(df_rp_q()$joint_prob," year RP (All-in)"),
      q_ind_SON= paste0(df_rp_q()$indiv_prob," year RP (weighted batches)"),
      q_jp_SON= paste0(df_rp_q()$joint_prob," year RP (All-in)")
    ) %>%
    tab_spanner(
      label = "Window 1 (MJJ)",
      columns = ends_with("MJJ")
    ) %>%
    tab_spanner(
      label = "Window 2 (JJA)",
      columns = ends_with("JJA")
    ) %>%
    tab_spanner(
      label = "Window 3 (SON)",
      columns = ends_with("SON")
    ) %>%
    fmt_number(
      decimals= 0
    ) %>%
    data_color(columns = where(is.numeric),
               direction = "column",
               reverse = TRUE,
               palette = "Reds"
    ) %>%
    tab_header(
      title = "ECMWF Trimester Threshold Options Based on Selected Monitoring Window & Selected Return Period",
    )%>%
    cols_width(
      # adm0_es ~ px(150),
      everything() ~ px(100)
    ) %>% 
    tab_options(
      data_row.padding = px(1),
    )
  # tab_footnote(
  #   gt::html(
  #     paste0(
  #       "<b>MJJ</b> - based on ", paste0(month(input$w1_monitor %>% unname(),abbr=T,label=T),collapse = "-")," monitoring<br>
  #       <b>JJA</b> - based on Feb-May monitoring<br>
  #       <b>SON</b>- based on May-July Monitoring"
  #   )
  # )
  # )
})
```

```{r echo=F,eval=F}
df_iri_ecmwf <- bind_rows(
  df_full %>% 
    select(
      adm0_es, init_valid_date,seas_gen, value = mm , lgl_flag
    ) %>% 
    mutate(
      source = "ECMWF"
    ),
  df_iri_full %>% 
    select(
      adm0_es, init_valid_date=predict_start_mo,seas_gen, value = mean , lgl_flag
    ) %>% 
    mutate(
      source = "IRI"
    )
)
df_iri_ecmwf %>% 
  group_by(
    adm0_es,init_valid_date,seas_gen
  ) %>% 
  filter(any(source=="IRI")) %>% 
  arrange( adm0_es,init_valid_date)

df_iri_ecmwf %>% 
  mutate(
    date_cat = dense_rank(init_valid_date)
  ) %>% 
  ggplot(aes(x=date_cat,y=source,fill=lgl_flag))+
  geom_tile(color="black")+
  facet_grid(rows=vars(adm0_es))

df_vhi_p <- df_vhi_plot %>% 
  select(
    adm0_es,init_valid_date= date, mo_label,value= pct_crop_pixels_lte_thresh, lgl_flag= flag
  ) %>% 
  mutate(
    source ="VHI",
    seas_gen = "JJA"
  ) %>% 
  group_by(
    adm0_es,yr_date = floor_date(init_valid_date,"year"),seas_gen
  ) %>% 
  summarise(
    flag_label = paste0(unique(mo_label[lgl_flag]),collapse = " & "),
    flag_label= if_else(flag_label=="",NA,flag_label),
    .groups="drop"
  ) %>% 
  mutate(
    init_valid_date = floor_date(yr_date,"year")+months(5)
  ) %>% 
  ungroup() %>% 
  select(-yr_date) 

df_iri_ecmwf_p <- df_iri_ecmwf %>% 
  # count(source)
  group_by(adm0_es, init_valid_date,seas_gen) %>%
  summarise(
    flag_label = paste0(unique(source[lgl_flag]),collapse = " & "),
    flag_label= if_else(flag_label=="",NA,flag_label),
    .groups="drop"
  )%>%
  arrange(init_valid_date, seas_gen) %>% 
  mutate(
    source ="forecast"
  ) %>% 
  bind_rows(
    df_vhi_p %>% 
      mutate(
        source = "VHI"
      )
  ) %>%
  # filter(year(init_valid_date)%in% 1990:1992) %>%
  # count(flag_label) %>% 
  mutate(
    date_cat = dense_rank(init_valid_date),
    xlabel = paste0(seas_gen,format(init_valid_date,"%y")),
    yr_date = format(floor_date(init_valid_date,"year"),"%Y")
  ) 

df_p_split <- df_iri_ecmwf_p%>% 
  split(.$source)

df_p_split$forecast %>% 
  ggplot(aes(x=date_cat,y=adm0_es))+
  geom_tile( aes(fill=flag_label,color=flag_label),lwd=0.5) +
  scale_x_continuous(
    breaks = unique(df_p_split$forecast$date_cat)
  )+
  facet_grid(
    cols=vars(yr_date),
    scales="free"
  )+
  theme(
    strip.text = element_text(size=8, color="white",angle=90),
    strip.background = element_rect(fill="black"),
    axis.text.x.bottom=element_blank(),
    panel.background = element_rect(fill = "black"),
    plot.background = element_rect(fill = "black"),
    axis.text.x = element_text(angle = 90, hjust = 1,size=8),
    legend.background = element_rect(fill="black"),
    axis.title = element_blank(),
    text=element_text(color="white")
  )



df_iri_ecmwf_p_relabel <- df_iri_ecmwf_p %>% 
  group_by(
    adm0_es,init_valid_date,seas_gen,date_cat,yr_date
  ) %>% 
  summarise(
    flag_label2 = paste0(unique(flag_label[!is.na(flag_label)]),collapse = " & "),
    .groups="drop"
  ) %>% 
  mutate(
    flag_label3= case_when(
      flag_label2=="IRI" ~ "Ag AA (IRI)",
      flag_label2=="ECMWF" ~ "Ag AA (ECMWF)",
      flag_label2=="IRI & ECMWF" ~ "Ag AA (ECMWF & IRI)",
      flag_label2=="ECMWF & IRI" ~ "Ag AA (ECMWF & IRI)",
      flag_label2=="ECMWF & Aug" ~ "Ag AA (ECMWF) + AA mitigation package (Aug)",
      flag_label2=="ECMWF & Jul"  ~ "Ag AA (ECMWF) + AA mitigation package (Jul)",
      flag_label2=="ECMWF & Jul & Aug" ~ "Ag AA (ECMWF) + AA mitigation package (Jul+Aug)",
      flag_label2=="Aug" ~ "AA mitigation package (Aug)",
      flag_label2=="Jul & Aug"  ~ "AA mitigation package (Jul+Aug)",
      
      TRUE ~ flag_label2
    ),
    flag_label3= ifelse(flag_label3=="",NA,flag_label3)
  ) 

df_fill_pal <- df_iri_ecmwf_p_relabel %>% 
  ungroup() %>% 
  filter(!is.na(flag_label3)) %>% 
  distinct(flag_label3) %>% 
  mutate(
    fill_pal = case_when(
      str_detect(flag_label3,"(ECMWF)")~hdx_hex("tomato-hdx"),
      str_detect(flag_label3,"(IRI)")~hdx_hex("tomato-light"),
      str_detect(flag_label3,"(ECMWF & IRI)")~hdx_hex("tomato-dark"),
    ),
    col_pal = case_when(
      str_detect(flag_label3,"(Jul+Aug)")~"darkgreen",
      str_detect(flag_label3,"(Jul)")~"lightgreen",
      str_detect(flag_label3,"(Aug)")~"green",
      .default=NA
    )
  )
v_fill_pal <- set_names(df_fill_pal$fill_pal,df_fill_pal$flag_label3)
v_col_pal <- set_names(df_fill_pal$col_pal,df_fill_pal$flag_label3)

df_iri_ecmwf_p_relabel %>% 
  ggplot(aes(x=date_cat,y=adm0_es))+
  geom_tile( aes(fill=flag_label3,
                 color=flag_label3
  ),lwd=0.5)+
  scale_fill_manual(
    na.value = NA,
    values = v_fill_pal)+
  scale_color_manual(
    na.value = NA,,
    values = v_col_pal
  )+
  scale_x_continuous(
    breaks =df_iri_ecmwf_p_relabel$date_cat
  )+
  facet_grid(
    cols=vars(yr_date),
    scales="free"
  )+
  theme(
    strip.text = element_text(size=8, color="white",angle=90),
    strip.background = element_rect(fill="black"),
    axis.text.x.bottom=element_blank(),
    panel.background = element_rect(fill = "black"),
    plot.background = element_rect(fill = "black"),
    axis.text.x = element_text(angle = 90, hjust = 1,size=8),
    legend.background = element_rect(fill="black"),
    axis.title = element_blank(),
    text=element_text(color="white")
  )




```

## histroical timeseries

```{r, echo=F}
inputPanel(
  checkboxGroupInput(inputId = "ecmwf_show_windowr",
                     choices = c("MJJ","JJA","SON"),
                     selected = c("JJA","SON"),inline = T,
                     label = "Plot Windows (ECMWF)",
  )
)
renderPlot({
  
  df_rp_q()$df_full %>% 
    mutate(
      seas_gen = fct_relevel(seas_gen,c("MJJ","JJA","SON"))
    ) %>% 
    filter(
      seas_gen %in% input$ecmwf_show_windowr
    ) %>%
    ggplot(
      aes(x=init_valid_date,y=mm, fill=lgl_flag, color=lgl_flag)
    )+
    geom_point(
      stat="identity"
    )+
    scale_color_manual(values =unname(plt_color))+
    
    facet_grid(
      rows = vars(adm0_es),
      cols = vars(seas_gen)
    )+
    geom_hline(
      data = . %>% 
        distinct(adm0_es,seas_gen,q_ind),
      aes(yintercept = q_ind)
    )+
    geom_text(
      data= . %>% 
        filter(lgl_flag),
      aes(x=init_valid_date, y= mm-50,label = format(init_valid_date,"%y"))
    )+
    theme(
      axis.title.x = element_blank(),
      legend.position  = "none"
    )
})




```


## IRI 
```{r, echo=F}

df_iri_rp_q <- reactive({
  q_rp <- 1/input$ecmwf_rp
  
  eq_probs <- quad_eq(a = -1, b = 2, c = -q_rp)
  q_jrp <- eq_probs[1]
  rp_jp <- 1/eq_probs[1]
  
  df_iri_max_prob <- df_iri_adm0_pre %>% 
    filter(
      (seas_gen == "MJJ" & month(date) %in% input$w1_monitor)|
        (seas_gen == "JJA" & month(date) %in% input$w2_monitor)|
        (seas_gen == "SON" & month(date) %in% input$w3_monitor)
    ) %>% 
    group_by(
      adm0_es,predict_start_mo,seas_gen
    ) %>% 
    summarise(
      mean=max(mean),
      .groups="drop"
    )
  
  df_iri_max_prob_quantiles <-  df_iri_max_prob %>% 
    group_by(
      adm0_es,seas_gen
    ) %>% 
    summarise(
      q_ind = quantile(mean,1-q_rp),
      q_jp = quantile(mean,1-q_jrp),
      .groups="drop"
      
    ) 
  
  df_iri_full <- df_iri_max_prob %>% 
    left_join(
      df_iri_max_prob_quantiles
    ) %>% 
    mutate(
      lgl_flag = mean>=q_ind
    )
  list(
    df= df_iri_max_prob_quantiles,
    indiv_prob = input$ecmwf_rp,
    joint_prob = round(rp_jp,1),
    df_full = df_iri_full
  )
  
})

```


```{r, echo=F}

render_gt({
  df_iri_rp_q()$df %>% 
    pivot_wider(
      names_from = seas_gen,
      values_from = q_ind:q_jp
    ) %>% 
    ungroup() %>% 
    gt() %>%
    cols_hide(columns = "q_jp_MJJ") %>% 
    tab_spanner(
      label="MJJ",
      ends_with("MJJ")
    ) %>% 
    tab_spanner(
      label="JJA",
      ends_with("JJA")
    ) %>% 
    tab_spanner(
      label="SON",
      ends_with("SON")
    ) %>% 
    cols_label(
      adm0_es= "Country",
      q_ind_MJJ= paste0(df_iri_rp_q()$indiv_prob," year RP (weighted batches)"),
      q_ind_JJA= paste0(df_iri_rp_q()$indiv_prob," year RP (weighted batches)"),
      q_jp_JJA= paste0(df_iri_rp_q()$joint_prob," year RP (All-in)"),
      q_ind_SON= paste0(df_iri_rp_q()$indiv_prob," year RP (weighted batches)"),
      q_jp_SON= paste0(df_iri_rp_q()$joint_prob," year RP (All-in)")
    ) %>% 
    fmt_number(
      decimals = 1
    ) %>% 
    data_color(columns = where(is.numeric),
               direction = "column",
               reverse = TRUE,
               palette = "Reds"
    ) %>%
    tab_header(
      title = "IRI Trimester Threshold Options Based on Selected Monitoring Window & Selected Return Period",
    )%>%
    cols_width(
      # adm0_es ~ px(150),
      everything() ~ px(100)
    ) %>% 
    tab_options(
      data_row.padding = px(1),
    )
})



```

```{r, eval=T, echo=F}
inputPanel(
  checkboxGroupInput(inputId = "iri_show_windows",
                     choices = c("MJJ","JJA","SON"),
                     selected = c("JJA","SON"),inline = T,
                     label = "Plot Windows (IRI)",
  )
)
# df_ck <-  df_iri_adm0_pre %>% 
#     # filter(
#     #   (seas_gen == "MJJ" & month(date) %in% input$w1_monitor)|
#     #     (seas_gen == "JJA" & month(date) %in% input$w2_monitor)|
#     #     (seas_gen == "SON" & month(date) %in% input$w3_monitor)
#     # ) %>% 
#     group_by(
#       adm0_es,predict_start_mo,seas_gen
#     ) %>% 
#     summarise(
#       mean=max(mean),
#       .groups="drop"
#     )


renderPlot({
  df_iri_rp_q()$df_full %>% 
    mutate(
      yr_date = floor_date(
        predict_start_mo,
        unit = "year"
      ),
      seas_gen = fct_relevel(
        seas_gen,
        "MJJ","JJA","SON"
      )
    ) %>%
    filter(seas_gen %in% input$iri_show_windows) %>%
    ggplot(
      aes(x=yr_date, y=mean) 
    )+
    geom_point(
      aes(color=lgl_flag, fill=lgl_flag)
    )+
    scale_color_manual(
      values = unname(plt_color)
    )+
    # geom_line()+
    facet_grid(
      rows = vars(adm0_es),
      cols = vars(seas_gen)
    )+
    geom_hline(
      data = . %>% 
        distinct(adm0_es,seas_gen,q_ind),
      aes(yintercept = q_ind)
    )+
    geom_text(
      data= . %>% 
        filter(lgl_flag),
      aes(x=yr_date, y= mean+7,label = format(yr_date,"%y"))
    )+
    theme(
      axis.title.x = element_blank(),
      legend.position  = "none"
    )
})

```



## VHI/ASIS

ASIS represents the % of cropland in drought conditions (as measured by VHI). FAO has identified July & August to be the critical months of the primera growing season to monitor ASIS. These months also correspond to the mid-summer drought (Canicula).

Below you can adjust the VHI drought threshold and to view the % of cropland below the defined threshold for the historical record for both `July` and `August`. You can then also adjust the % of cropland used to flag drought conditions to see which years would be flagged.

**The default values** are set based on FAOs recommendations:
  
  - Typically VHI ≤ 0.35 is considered to be drought effected.
- ≥ 25 % of cropland

```{r vhi, echo=FALSE}
inputPanel(
  sliderInput(inputId = "vhi_thresh", label = "VHI threshold:",
              min = 0, max = 1, value = 0.35, step = 0.05),
  sliderInput(inputId = "vhi_pct_area", label = "% Cropland threshold:",
              min = 0, max = 1, value = 0.25, step = 0.05)
)

#.1 .35 - 3.5 salvador

df_vhi_plot <- reactive({
  df_plot <- df_cropland_lte_vhi_threshold_dc %>%
    filter(
      abs(threshold-input$vhi_thresh)<0.01
    ) %>% 
    mutate(
      date = as_date(paste0(date,"-01"))
    ) %>% 
    filter(
      month(date) %in% c(7,8)
    ) %>% 
    mutate(
      mo_label = month(date,abbr=T, label=T),
      flag = pct_crop_pixels_lte_thresh>=input$vhi_pct_area
    ) %>% 
    group_by(adm0_es,mo_label) %>% 
    mutate(
      activation_rate = mean(flag),
      rp = 1/activation_rate,
      adm_lab = paste0(adm0_es, " (~", round(rp,1)," year RP)")
    ) %>% 
    ungroup()
  
})

renderPlot({
  df_vhi_plot()%>% 
    filter(
      month(date)==7
    ) %>% 
    ggplot(
      aes(x=date, y=pct_crop_pixels_lte_thresh, fill=flag)
    )+
    geom_bar(stat="identity")+
    scale_fill_manual(values = unname(plt_color))+
    geom_hline(
      yintercept = input$vhi_pct_area,
      linetype = "dashed",
      color = hdx_hex("tomato-hdx")
    )+
    labs(
      y= "%",
      title = "Historical Analaysis of VHI in July",
      subtitle = paste0("% of cropland in dry corridor ≤ a vhi of ",input$vhi_thresh)
    )+
    scale_y_continuous(
      labels = scales::label_percent()
    )+
    geom_text(
      data= . %>% 
        filter(
          flag
        ),
      aes(x= date, y= pct_crop_pixels_lte_thresh+0.05, label = format(date,"%y")),
    )+
    facet_wrap(~adm_lab)+
    theme(
      axis.title.x = element_blank(),
      legend.position="none"
    )
})
renderPlot({
  df_vhi_plot()%>% 
    filter(
      month(date)==8
    ) %>% 
    ggplot(
      aes(x=date, y=pct_crop_pixels_lte_thresh, fill=flag)
    )+
    geom_bar(stat="identity")+
    geom_hline(
      yintercept = input$vhi_pct_area,
      linetype = "dashed",
      color = hdx_hex("tomato-hdx")
    )+
    scale_fill_manual(values = unname(plt_color))+
    labs(
      y= "%",
      title = "Historical Analaysis of VHI in August",
      subtitle = paste0("% of cropland in dry corridor ≤ a vhi of ",input$vhi_thresh)
    )+
    scale_y_continuous(
      labels = scales::label_percent()
    )+
    geom_text(
      data= . %>% 
        filter(
          flag
        ),
      aes(x= date, y= pct_crop_pixels_lte_thresh+0.05, label = format(date,"%y")),
    )+
    facet_wrap(~adm_lab)+
    theme(
      axis.title.x = element_blank(),
      legend.position="none"
    )
})
```


## Initial Recommendations

- Use ECMWF for seasonal forecast due to longer historical record.




## Appendix

```{r eval=F ,echo=F}
#   df_r2 <- df_era_seas_win %>% 
#     group_by(adm0_es,lt) %>% 
#     nest(data= c(-lt,-adm0_es) )%>% 
#     mutate(
#       corr_spear = map(data ,~cor.test(.x$mm,.x$mm_obs)),
#       tidy =map(corr_spear,tidy),
#       glanced = map(corr_spear,glance)
#     ) %>% 
#     unnest(tidy) %>% 
#     select(adm0_es, lt, estimate)
df_era_seas_win %>% 
  mutate(
    valid_mo= month(pub_date +months(lt))
  ) %>% 
  pull(valid_mo) %>% 
  unique()

title_valid_mo <- glue_collapse(month(as.numeric(input$winA_forecast),label=T, abbr=T),"-")
input.winA_forecast
df_era_seas_win %>%
  left_join(df_r2) %>% 
  distinct(adm0_es, lt, estimate)


df_era_seas_win %>%
  left_join(df_r2) %>%
  ggplot(
    aes(x= mm, y= mm_obs)
  )+
  geom_point()+
  geom_text(
    data= . %>%
      distinct(adm0_es, lt, estimate),
    aes(label= paste0("R2: ",round(estimate,2))), x= 900,y=400
  )+
  # geom_smooth(method = "lm", se=FALSE, color="black", formula = y ~ x)+
  geom_abline (slope=1, linetype = "dashed", color="Red")+
  facet_grid(
    rows= vars(adm0_es),
    cols = vars(lt)
  )
distinct(adm0_es, lt, estimate)
```


# Select RP

```{r echo=F, eval=F}
inputPanel(
  sliderInput(inputId = "sel_ecmwf_rp", label = "Desired RP:",
              min = 0, max = 20, value = 4, step = 1)
)


apply_rps <- reactive({
  q_rp <- 1/input$sel_ecmwf_rp
  
  
  df_win <- df_win1()
  df_ecmwf_thresh <- df_win  %>% 
    group_by(adm0_es,lt) %>% 
    summarise(
      q_ind = quantile(mm,q_rp),
      .groups="drop"
      
    ) 
  
  df_full <- df_win %>% 
    left_join(
      df_ecmwf_thresh
    ) %>% 
    mutate(
      lgl_flag = mm<q_ind
    ) 
  
  
  df_overall_activation_rate <- df_full %>% 
    group_by(adm0_es,yr=year(pub_date)) %>% 
    summarise(
      lgl_flag = any(lgl_flag),.groups="drop_last"
    ) %>% 
    summarise(
      ar_overall= mean(lgl_flag),
      rp_overall =1/ar_overall
    )
  
  rp_by_lt <- df_ecmwf_thresh %>% 
    pivot_wider(
      names_from= lt,
      values_from = q_ind
    ) %>% 
    left_join(
      df_overall_activation_rate
    )
  list(
    df= df_full,
    rp_tbl = rp_by_lt
  )
})

# change this to fmt_number diferently for different cols
render_gt({
  apply_rps()$rp_tbl %>% 
    gt() %>% 
    cols_label(
      adm0_es="Country" ,
      ar_overall="Activation rate (overall)" ,
      rp_overall="Return period (overall)"
    ) %>% 
    tab_spanner(
      label = "Thresholds by LT",
      columns = any_of(c("0","1","2","3","4","5","6"))
    ) %>%
    fmt_number(columns = any_of(c("0","1","2","3","4","5","6")),decimals=0) %>% 
    fmt_number(columns = c("rp_overall"),decimals =2) %>% 
    fmt_percent(columns = c("ar_overall"),decimals =0) 
})

```


Looking at the correlation between VHI July & Aug vs JJA forecast (ECMWF)
```{r, echo=F}
radioButtons(inputId="ecmwf_vs_vhi", label="Choose a transform for %", 
             choices=c("none"= "none","log"="log","Pseudo log"= "pseudo_log"),
             selected = "log",
             inline = TRUE)

# df_ecmwf_zonal_filt_mins2 <- df_ecmwf_zonal %>% 
#   group_by(
#     adm0_es,init_valid_date,init_year,seas_gen
#   ) %>% 
#   filter(seas_gen=="JJA") %>% 
#   summarise(
#     mm=min(mm),.groups="drop"
#   ) %>% 
#   mutate(
#     yr_date=floor_date(init_valid_date,"year")
# )

df_ecmwf_vhi_jja <- reactive({
  df_ecmwf_jja <- df_rp_q()$df_full %>% 
    group_by(
      adm0_es,init_valid_date,init_year,seas_gen
    ) %>% 
    filter(seas_gen=="JJA") %>% 
    summarise(
      mm=min(mm),.groups="drop"
    ) %>% 
    mutate(
      yr_date=floor_date(init_valid_date,"year")
    )
  
  df_vhi_pct_avg <- df_vhi_plot() %>% 
    mutate(
      yr_date= floor_date(date,"year")
    ) %>% 
    group_by(
      adm0_es,yr_date
    ) %>% 
    summarise(
      pct = mean(pct_crop_pixels_lte_thresh),
      .groups="drop"
    )
  df_ecmwf_jja %>% 
    left_join(df_vhi_pct_avg)
})


renderPlot({
  p <- df_ecmwf_vhi_jja() %>% 
    ggplot(
      aes(x= mm, y= pct)
    )+
    geom_point()
  if(input$ecmwf_vs_vhi == "none"){
    ret <- p+
      scale_y_continuous(labels = scales::label_percent())
  }
  if(input$ecmwf_vs_vhi == "log"){
    ret <- p+
      scale_y_log10(labels = scales::label_percent())
  }
  if(input$ecmwf_vs_vhi == "pseudo_log"){
    ret <- p+
      scale_y_continuous(labels = scales::label_percent(),trans= scales::pseudo_log_trans())
  }
  return(ret)
})


# 
# df_cropland_lte_vhi_threshold_dc %>% 
#   mutate(
#     date= as_date(paste0(date,"-01"))
#   ) %>% 
#   filter(
#     month(date) %in% c(7,8)
#   ) %>% 
#   mutate(
#     yr_date=floor_date(date,"year")
#   ) %>% 
#   group_by(
#     adm0_es,yr_date,threshold
#   ) %>% 
#   summarise(
#     pct = mean(pct_crop_pixels_lte_thresh)
#   ) %>% 
#   left_join(
#     df_ecmwf_zonal_filt_mins2
#   ) %>% 
#   nest(
#     data= -threshold
#   ) %>% 
#   mutate(
#     fit = map(data,~cor.test(.x$mm,log10(.x$pct))),
#     tidy = map(fit,broom::tidy)
#   ) %>% 
#   unnest(tidy)

```